---
title: "xcms-based preprocessing of LC-MS/MS data for feature-based molecular
networking with GNPS2"
format:
  html
authors: Philippine Louail, Steffen Neumann, Johannes Rainer
---


# Introduction

This document describes data inspection and preprocessing of an LC-MS/MS data
set using *xcms* and export of the data for subsequent feature-based molecular
networking (FBMN) with GNPS2. Functionality from different packages from the
RforMassSpectrometry package ecosystem are combined to visualize and process the
data.

For details and more in depth description of the various visualizations and
analysis options as well as parameter choices see also the [Metabonaut](https://rformassspectrometry.github.io/Metabonaut) tutorials.

# Required software packages

The various software packages required for the analysis are defined and loaded
below. All packages are available through Bioconductor or CRAN and can be
installed with `BiocManager::install(<package name>)`.

```{r}
library(Spectra) # main MS infrastructure for R
library(MsExperiment) # container for MS data
library(xcms)    # for preprocessing of LC-MS and LC-MS/MS data

library(RColorBrewer) # to define colors
library(pander)       # to format tables
library(pheatmap)     # visualization of clustering results as heatmap
library(vioplot)      # to create *violin plots*
```

# Data import

The data analyzed here is part of the MassIVE
[MSV000090156](https://massive.ucsd.edu/ProteoSAFe/dataset.jsp?task=06bd49807caa4390961fb827606a8696)
data set. The full data set (raw data files) should first downloaded from the
respective directory of the ftp server:
[ftp://massive-ftp.ucsd.edu/v04/MSV000090156/](ftp://massive-ftp.ucsd.edu/v04/MSV000090156/).
Here we will analyze the data from *Lab 2*. Before loading the data we define a
`data.frame` with sample and experiment-specific information for the individual
MS runs/data files. These should ideally comprise all relevant phenotypic but
also technical information (e.g. injection index) to allow proper adjusting or
modeling of the data.

```{r}
pd <- data.frame(
    file_name = c("Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep1.mzML",
                  "Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep2.mzML",
                  "Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep3.mzML",
                  "Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep1.mzML",
                  "Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep2.mzML",
                  "Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep3.mzML",
                  "Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep1.mzML",
                  "Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep2.mzML",
                  "Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep3.mzML",
                  "Interlab-LC-MS_Lab2_M_Pos_MS2_Rep1.mzML",
                  "Interlab-LC-MS_Lab2_M_Pos_MS2_Rep2.mzML",
                  "Interlab-LC-MS_Lab2_M_Pos_MS2_Rep3.mzML",
                  "Interlab-LC-MS_Lab2_PPL_Pos_MS2_Rep1.mzML"),
    sample_name = c("A15M", "A15M", "A15M",
                    "A45M", "A45M", "A45M",
                    "A5M", "A5M", "A5M",
                    "M", "M", "M",
                    "PPL"),
    sample_desc = c("A15M_R1", "A15M_R2", "A15M_R3",
                    "A45M_R1", "A45M_R2", "A45M_R3",
                    "A5M_R1", "A5M_R2", "A5M_R3",
                    "M_R1", "M_R2", "M_R3",
                    "PPL_R1"),
    replicate = c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1)
)
```

It is assumed that the full data folder was downloaded from MassIVE and stored
within the *data* sub-folder of the present working directory. Below we define
the path to the data files and load the data set.

```{r}
path <- file.path("data", "MSV000090156", "peak", "mzml", "POS_MSMS", "Lab_2")
mse <- readMsExperiment(file.path(path, pd$file_name),
                        sampleData = pd)
mse
```

The samples and data files from the present data set are displayed in the table
below. Note that in the R code block below we use the R *pipe* operator `|>` to
avoid nested function calls and improve the readability of the code.

```{r, results = "asis"}
sampleData(mse)[, c("sample_name", "sample_desc", "replicate")] |>
    as.data.frame() |>
    pandoc.table(style = "rmarkdown", split.table = Inf)
```

We in addition also define different colors for the individual samples.

```{r}
#' Define a color for each unique original sample
col <- sampleData(mse)$sample_name |>
                     unique() |>
                     length() |>
                     brewer.pal("Set2")
names(col) <- unique(sampleData(mse)$sample_name)

#' Define a color for each data file/sample
col_sample <- col[sampleData(mse)$sample_name]
```

# Data visualization and general quality assessment

For data inspection and a general data overview we first create base peak
chromatograms (BPC) and total ion chromatograms (TIC) of the data set using the
`chromatograms()` functions specifying either `"max"` (for BPC) or `"sum"` (for
TIC) as the function to aggregate the per-spectrum intensities.

```{r}
#' BPC
bpc <- chromatogram(mse, aggregationFun = "max")

plot(bpc, col = paste0(col_sample, 80), main = "BPC", lwd = 2)
grid()
legend("topright", col = col, legend = names(col), lty = 1, lwd = 2)
```

```{r}
#' TIC
tic <- chromatogram(mse, aggregationFun = "max")

plot(tic, col = paste0(col_sample, 80), main = "TIC", lwd = 2)
grid()
legend("topright", col = col, legend = names(col), lty = 1, lwd = 2)
```

Based on the BPC and TIC there seems to be little retention time shifts between
the samples. Also, no signal seems to be present before 20 seconds and after 850
seconds. Thus, we below filter the data set to spectra acquired within this
retention time range.

```{r}
mse <- filterSpectra(mse, filterRt, c(20, 850))
```

BPC and TIC aggregate data along the *m/z* dimension per spectrum (retention
time) to compare the signal measured along the retention time. To compare the
*mass* or ion content of the individual samples/measurement runs we in addition
aggregate data along the retention time, for distinct *m/z* values.

To this end we first bin each spectrum to get discrete and similar *m/z* values
within the data set.

```{r}
#' Bin mass peaks into into discrete m/z bins of 0.02 Da.
s_bin <- spectra(mse) |>
    filterMsLevel(1L) |>
    bin(binSize = 0.02)

#' Combine all spectra within the same sample into a single spectrum reporting
#' the maximum intensity of all mass peaks with the same m/z bin
bps <- combineSpectra(s_bin, f = s_bin$dataOrigin, intensityFun = max)
#' The same but reporting the sum of intensities per m/z bin
tis <- combineSpectra(s_bin, f = s_bin$dataOrigin, intensityFun = sum)
```

We have thus a single aggregated mass spectrum per sample. These spectra are
plotted below.

```{r}
plotSpectra(bps)
```

The *mass content* of the samples seems to be similar, with the exception of the
last file. We can also plot all spectra into the same plot, using a different
color per sample.

```{r}
plotSpectraOverlay(bps, col = paste0(col_sample, 40))
grid()
legend("topright", col = col, legend = names(col), lty = 1)
```

We can also use these aggregated spectra to calculate spectra similarity between
the individual samples and cluster them.

```{r}
sim <- compareSpectra(bps)
rownames(sim) <- colnames(sim) <- sampleData(mse)$sample_desc
pheatmap(sim)
```

A15M, A5M and M samples cluster together, separately from the A45M samples while
the PPL_R1 sample has a distinct mass peak profile.


# Data preprocessing

Data preprocessing is the first step in the analysis of LC-MS data processing
and analyzing the raw MS data to result in a two-dimensional quantification
table of LC-MS *features* in the various samples of the experiment. This process
consists of 3 main steps: **chromatographic peak detection**, **retention time
alignment** and **correspondence analysis**. An additional **gap-filling** step
can be conducted to reduce the number of missing values integrating raw MS
signal from the expected *m/z* by retention time areas of defined LC-MS
features.

Most methods in *xcms* are parallelized by default. It is thus advisable to
globally configure the parallel processing setup. On Unix machines *multi-core*
parallel processing can be used, that shares memory between the parallel
processes. Windows supports only *socket-based* parallel processing and starts a
separate R for each parallel process. Below we globally define the parallel
processing setup depending on the operating system. For the present analysis we
use 4 parallel processes.

```{r}
if (.Platform$OS.type == "unix") {
    register(MulticoreParam(4))
} else {
    register(SnowParam(4))
}
```

## Chromatographic peak detection

The aim of the chromatographic peak detection is to identify and quantify signal
in the raw MS data space representing signal from ions of compounds present in
a sample. Data processing is performed separately for each data file and mass
peak intensities with similar *m/z* are evaluated along retention time axis to
identify chromatographic peaks. We use the *centWave* algorithm for peak
detection. The most important parameter for *centWave* is the `peakwidth` which
defines an approximate lower and upper expected width of chromatographic peaks
in retention time dimension. Without any prior information, we need to derive
this information from the data set. We therefore zoom into areas of the BPC that
seem to contain signal from an ion.

```{r}
par(mfrow = c(2, 1))
bpc <- chromatogram(mse, aggregationFun = "max")
plot(bpc, col = paste0(col_sample, 80), lwd = 2)
grid()

#' identify a retention time region to extract
rtr_1 <- c(105, 130)
abline(v = rtr_1, lty = 2)

#' identify the m/z with the largest intensity in that region:
#' - restrict to MS1 data
#' - filter the MS data by retention time
#' - extract the MS data as a data.frame
tmp <- spectra(mse) |>
    filterMsLevel(1L) |>
    filterRt(rtr_1) |>
    longForm(columns = c("mz", "intensity"))

#' define a m/z range around the m/z with largest intensity
mzr_1 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)

#' extract an EIC for that RT and m/z region
eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1)
plot(eic_1, col = paste0(col_sample, 80), lwd = 2)
grid()
```

The width of this chromatographic peaks is about 8 seconds. We evaluate a second
signal at the and of the chromatogram.

```{r}
par(mfrow = c(2, 1))
plot(bpc, col = paste0(col_sample, 80), lwd = 2)
grid()

#' identify a region to extract
rtr_2 <- c(720, 770)
abline(v = rtr_2, lty = 2)

#' identify the m/z with the largest intensity in that region:
#' - restrict to MS1 data
#' - filter the MS data by retention time
#' - extract the MS data as a data.frame
tmp <- spectra(mse) |>
    filterMsLevel(1L) |>
    filterRt(rtr_2) |>
    longForm(columns = c("mz", "intensity"))

#' define a m/z range around the m/z with largest intensity
mzr_2 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)

#' extract an EIC for that RT and m/z region
eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2)
plot(eic_2, col = paste0(col_sample, 80), lwd = 2)
grid()
```

The width of the chromatographic peaks for that *m/z* slice seem to be around 15
seconds. Also, there seems to be a considerable shift in retention times between
the samples.

Based on these two example signals we define the `peakdwidth` for the present
data set to be between and 5 and 20 seconds. For a *real* data analysis it is
suggested to evaluate more signals, also eventually of internal standards or
ions of compounds that are expected to be present in the sample.

A second potentially data set-specific parameter of the *centWave* algorithm is
`ppm`. It defines the maximum allowed deviation in *m/z* dimension of mass peaks
in consecutive spectra considered to represent signal from the same ion. This
scattering of mass peak's *m/z* values can depend on the centroiding algorithm
used. In addition, on TOF instruments, the scattering can depend on the
intensity of the signal, with higher variation observed for low intensity peaks
and increasing stability with higher signal. To illustrate this we below subset
the full MS data from the first data file to the *m/z* and retention time range
defined above and plot the individual mass peaks.

```{r}
mse[1L] |>
    filterSpectra(filterMsLevel, 1L) |>
    filterSpectra(filterRt, rt = rtr_1) |>
    filterSpectra(filterMzRange, mz = mzr_1) |>
    plot()
```

The individual mass peaks are shown in the lower panel in the plot above. For
the present ion, the *m/z* values show a very low variance.

We evaluate the signal also for the second *m/z* - retention time window defined
above.

```{r}
mse[1L] |>
    filterSpectra(filterMsLevel, 1L) |>
    filterSpectra(filterRt, rt = rtr_2) |>
    filterSpectra(filterMzRange, mz = mzr_2) |>
    plot()
```

The scattering of *m/z* values looks larger, but is still below 0.001 Da. We
nevertheless use a `ppm = 20` for the present data set - as we do not assume
that ions from different compounds elute at the same time with a difference in
ppm lower than 20.

Below we define the settings for *centWave* and perform the chromatographic peak
detection on the full data set. Note that it can also be helpful to test the
different settings by performing peak detection on extracted ion chromatograms
as described in
[Metabonaut](https://rformassspectrometry.github.io/Metabonaut/). Parameter
`chunkSize` defines the number of data files from which MS data should be loaded
at a time. This parameter thus has an influence on the memory usage of the
analysis.

```{r}
cwp <- CentWaveParam(
    ppm = 20,
    peakwidth = c(5, 20),
    snthresh = 8,
    integrate = 2,
    mzdiff = 0.001
)
mse <- findChromPeaks(mse, param = cwp, chunkSize = 4L)
```

In most cases it is also advisable to perform a *peak postprocessing* to remove
artifacts of the *centWave* peak detection (e.g. overlapping or split
peaks). Below we perform such peak refinement which will merge partially or
completely overlapping chromatographic peak, or those that are less than 2
seconds apart from each other, if the intensity below both apexes is lower than
a certain proportion of the apex intensity of the lower intensity peak.

```{r}
mnpp <- MergeNeighboringPeaksParam(
    expandRt = 1,
    expandMz = 0,
    ppm = 0,
    minProp = 0.75)
mse <- refineChromPeaks(mse, mnpp, chunkSize = 4L)
```

We next compare the number of identified peaks per sample as well as their *m/z*
and retention time widths.

```{r}
#' split the detected chrom peaks per sample
pk_list <- split.data.frame(
    chromPeaks(mse, columns = c("mzmin", "mzmax", "rtmin", "rtmax")),
    chromPeaks(mse, columns = "sample")[, "sample"])
#' calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
    cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
          mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mzmax"],
          rt_width = z[, "rtmax"] - z[, "rtmin"])
})

#' plot the information
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
     col = col_sample,
     ylab = "peak count", main = "Peak detection summary, mse", xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col, pch = 15,
       legend = names(col))
par(mar = c(0, 4.3, 0, 0.1))
vioplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
        ylab = "m/z width [ppm]", xaxt = "n",
        col = col_sample)
grid()
vioplot(lapply(pk_list, function(z) z[, "rt_width"]),
        ylab = "rt width [s]", col = col_sample)
grid()
```

The highest number of peaks was detected in the *PPL* sample. Apart from that
sample, the numbers of detected peaks is comparable in the data set. Also the
*m/z* width and the retention time widths. As expected, most of the identified
chromatographic peaks are about 10 seconds wide. Also, their *m/z* width is
below 10 ppm for most peaks, but some show also a larger *m/z* widths.

We also evaluate the peak detection results on the two example *m/z* - retention
time regions. Identified chromatographic peaks will be colored according to the
sample group.

```{r}
eic_1 <- chromatogram(mse, mz = mzr_1, rt = rtr_1)

#' define a color for each chromatographic peak
col_peak <- col_sample[chromPeaks(eic_1)[, "sample"]]
plot(eic_1, col = paste0(col_sample, 80),
     peakBg = paste0(col_peak, 10),
     peakCol = paste0(col_peak, 80))
grid()
legend("topright", col = col, lty = 1,
       legend = names(col))
```


```{r}
eic_2 <- chromatogram(mse, mz = mzr_2, rt = rtr_2)

#' define a color for each chromatographic peak
col_peak <- col_sample[chromPeaks(eic_2)[, "sample"]]
plot(eic_2, col = paste0(col_sample, 80),
     peakBg = paste0(col_peak, 10),
     peakCol = paste0(col_peak, 80))
grid()
legend("topright", col = col, lty = 1,
       legend = names(col))
```


## Retention time alignment

The aim of the retention time alignment step is to reduce differences observed
in the elution time of compounds between different LC-MS runs. A variety of
methods for this have been proposed and some are also implemented in *xcms*. We
use the most straight forward approach that aligns chromatographic runs based on
retention times of *anchor peaks*, i.e., compounds present in most of the
samples of an experiment. To define these anchor peaks we must however perform
an initial correspondence analysis to group chromatographic peaks with similar
*m/z* and retention time across samples. We use the *peak density* method for
this, which we configure below using the `PeakDensityParam`. For the initial
correspondence we used more relaxed settings, also putting all samples into the
same *sample group*. The important parameters are `bw` and `binSize`. The former
defines the tolerance of retention time similarity, the latter the similarity of
*m/z* values for chromatographic peaks from different samples to be considered
to represent signal from ions of the same compound. Setting `binSize` is
straight forward - it depends on the resolution of the instrument and the
expected similarity of *m/z* values for the same ion. We set it to a value of
`binSize = 0.01`, hence all chromatographic peaks with a difference in *m/z*
smaller than 0.01 would be evaluated. The `bw` parameter is a bit more difficult
to define. It should be defined based on observed data in the experiment,
ideally, on EICs of closely eluting compounds with the same *m/z*. In our
example we use the second example *m/z* - retention time range, because it
seemed to contain signal from the same compound, but with quite large shifts
between data files. We below *simulate* a correspondence analysis on this EIC.
Other parameters defined are `minFraction`, which defines the minimum required
proportion of samples of one of the sample groups defined with parameter
`sampleGroups` in which a chromatographic peak is present, and `ppm` which,
together with `binSize` defines the maximal accepted difference in
chromatographic peaks' *m/z* values to consider them for grouping.

The *peak density* method groups chromatographic peaks into an LC-MS feature, if
their *m/z* difference is smaller `binSize` (+ `ppm` of the *m/z*), the
retention time of their apex is within one peak of the *peak density*
curve and a chromatographic peak is present in at least `minFraction` of at
least one of the sample groups defined with `sampleGroups`. Below we run a
correspondence simulation with example settings.

```{r}
pdp <- PeakDensityParam(
    sampleGroups = rep(1, length(mse)),
    bw = 2,
    minFraction = 0.2,
    binSize = 0.01,
    ppm = 10)

col_peak <- col_sample[chromPeaks(eic_2)[, "sample"]]
plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,
                     peakBg = paste0(col_peak, 40))
grid()
```

The upper panel of this plot shows the EIC, the lower panel the data considered
for correspondence: it shows the retention time of the apex positions of all
chromatographic peaks in that *m/z* slice on the x-axis against the sample in
which the chromatographic peak was detected on the y-axis. The black solid line
represents the *peak density estimate*, calculated based on the retention times
of the chromatographic peaks and parameter `bw` with larger values of `bw`
resulting in more smooth curves.

With the used settings, in particular parameter `bw`, the present
chromatographic peaks would be split into two separate LC-MS features (indicated
with a grey rectangle in the lower panel). Assuming that all peaks in that
region represent signal from ions of the same compound, we however want to group
them into the same feature. We hence next increase the `bw` parameter and
simulate the correspondence with these updated settings.

```{r}
pdp@bw <- 5
plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,
                     peakBg = paste0(col_peak, 40))
grid()
```

Changing `bw` to 5 changed the density curve, but we still defined two separate
features. We thus increase below `bw` to 7.

```{r}
pdp@bw <- 7
plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,
                     peakBg = paste0(col_peak, 40))
grid()
```

With a `bw = 7` a single feature was defined. We use these parameter for the
initial correspondence analysis on the full data set.

```{r}
mse <- groupChromPeaks(mse, param = pdp)
```

For the retention time alignment we use the before mentioned *peak groups*
method that aligns LC runs by minimizing retention time differences of so called
anchor peaks. This alignment method is very robust and also flexible, allowing
for example to align samples based on within-experiment QC samples, or against
external reference data or based on manually defined anchor peaks. See
[Metabonaut](https://rformassspectrometry.github.io/Metabonaut) for examples and
options. The method can be configured with the `PeakGroupsParam`. With
`minFraction = 0.9` we below define anchor peaks as those LC-MS features for
which a chromatographic peak was identified in 90% of the samples in the
experiment. The observed retention time differences of these are used to model a
curve along retention time dimension which can then be used to align the
retention times of all samples. The smoothness of this curve along the retention
time dimension can be configured with `span`, values between 0.4 and 0.7 work
for most cases.

```{r}
pgp <- PeakGroupsParam(
    minFraction = 0.90,
    span = 0.4)
mse <- adjustRtime(mse, param = pgp)
```

The effect of this alignment can be visualized with the `plotAdjustedRtime()`
function. It plots the adjusted retention times of each sample on the x-axis
against the difference between the adjusted and raw retention times on the
y-axis as a solid line. Retention times of anchor peaks in each sample are
indicated with individual data points. These should ideally be placed along the
full retention time range of the experiment.

```{r}
#| fig-cap: "Retention time alignment results."
#' visualize alignment results
plotAdjustedRtime(mse, col = paste0(col_sample, 80),
                  peakGroupsPch = 21, lwd = 2)
grid()
legend("topleft", col = col, lty = 1,
       legend = names(col))
```

Anchor points span the full retention time range. Retention time adjustments for
most samples were below 2-4 seconds, with the exception of 3 samples for which a
considerably larger adjustment is present after 500 seconds, and the PPL sample
with larger retention time differences after 650 seconds.

We next evaluate the alignment results based on the BPC before and after
alignment.

```{r}
#' create a BPC after adjustment; chromPeaks = "none" only creates the BPC
#' without extracting also identified chromatographic peaks.
bpc_adj <- chromatogram(mse, chromPeaks = "none", aggregationFun = "max")

par(mfrow = c(2, 1))
plot(bpc, col = paste0(col_sample, 80), main = "BPC, raw", lwd = 2)
grid()
legend("topright", col = col, legend = names(col), lty = 1, lwd = 2)
plot(bpc_adj, col = paste0(col_sample, 80), main = "BPC, adjusted", lwd = 2)
grid()
```

Misalignment of signal at the later stage of the chromatography seems to be
reduced. We in addition evaluate the effect of retention time alignment on the
two example EICs.

```{r}
eic_1_adj <- chromatogram(mse, rt = rtr_1, mz = mzr_1, chromPeaks = "none")

par(mfrow = c(2, 1))
plot(eic_1, col = paste0(col_sample, 80), lwd = 2, peakType = "none")
grid()
legend("topright", col = col, legend = names(col), lty = 1, lwd = 2)
plot(eic_1_adj, col = paste0(col_sample, 80), lwd = 2)
grid()
```

For this early retention time range already the raw signal was aligned well.

```{r}
eic_2_adj <- chromatogram(mse, rt = rtr_2, mz = mzr_2, chromPeaks = "none")

par(mfrow = c(2, 1))
plot(eic_2, col = paste0(col_sample, 80), lwd = 2, peakType = "none")
grid()
legend("topright", col = col, legend = names(col), lty = 1, lwd = 2)
plot(eic_2_adj, col = paste0(col_sample, 80), lwd = 2)
grid()
```

This later retention time range shows clear, and strong, differences in
retention times of 4 samples. While the *PPL* sample could be aligned quite well
using the above settings, 3 samples still show shifts in retention times. We
re-perform the alignment reducing the value for the `span` parameter to allow a
more local alignment of the samples. We thus below first *undo* the retention
time alignment, re-perform the initial correspondence analysis and perform the
alignment with the changed settings for parameter `span`.

```{r}
#' remove retention time alignment results
mse <- dropAdjustedRtime(mse)
#' re-perform initial correspondence
mse <- groupChromPeaks(mse, param = pdp)
#' perform the alignment using updated settings
pgp <- PeakGroupsParam(
    minFraction = 0.90,
    span = 0.1)
mse <- adjustRtime(mse, param = pgp)
```

Evaluating the impact of changing this parameter.

```{r}
#| fig-cap: "Retention time alignment results."
#' visualize alignment results
plotAdjustedRtime(mse, col = paste0(col_sample, 80),
                  peakGroupsPch = 21, lwd = 2)
grid()
legend("topleft", col = col, lty = 1,
       legend = names(col))
```

A stronger alignment can be observed for the retention time area from 750 to 800
seconds. The results for the first example EIC did not change.

```{r}
eic_1_adj <- chromatogram(mse, rt = rtr_1, mz = mzr_1, chromPeaks = "none")

par(mfrow = c(2, 1))
plot(eic_1, col = paste0(col_sample, 80), lwd = 2, peakType = "none")
grid()
legend("topright", col = col, legend = names(col), lty = 1, lwd = 2)
plot(eic_1_adj, col = paste0(col_sample, 80), lwd = 2)
grid()
```

While for the second EIC the alignment improved.

```{r}
eic_2_adj <- chromatogram(mse, rt = rtr_2, mz = mzr_2, chromPeaks = "none")

par(mfrow = c(2, 1))
plot(eic_2, col = paste0(col_sample, 80), lwd = 2, peakType = "none")
grid()
legend("topright", col = col, legend = names(col), lty = 1, lwd = 2)
plot(eic_2_adj, col = paste0(col_sample, 80), lwd = 2)
grid()
```

Note that it is not necessary that all samples are perfectly aligned. Some
variation in retention time can be accounted for in the final correspondence
analysis grouping the chromatographic peaks across samples to the LC-MS
features.


## Correspondence analysis

## Gap-filling

# Formatting and exporting data for FBMS

# Session information
