[{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"setup-and-data-import","dir":"Articles","previous_headings":"","what":"Setup and Data Import","title":"Workshop: xcms preprocessing for GNPS2","text":"load xcms ecosystem. Spectra handles MS data, MsExperiment manages experimental design.","code":"library(MsExperiment) library(Spectra) library(xcms) library(MsBackendMgf) library(RColorBrewer)  library(pheatmap) library(vioplot)  # Parallel processing setup nb_cores <- 4 register(MulticoreParam(nb_cores)) # Change to SnowParam(4) if on Windows"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"define-experiment-metadata","dir":"Articles","previous_headings":"","what":"Define Experiment Metadata","title":"Workshop: xcms preprocessing for GNPS2","text":"define file paths grouping manually . production pipeline, read CSV file.","code":"# Define filenames and metadata pd <- data.frame(     file_name = c(\"Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep1.mzML\",                   \"Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep2.mzML\",                   \"Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep3.mzML\",                   \"Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep1.mzML\",                   \"Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep2.mzML\",                   \"Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep3.mzML\",                   \"Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep1.mzML\",                   \"Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep2.mzML\",                   \"Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep3.mzML\",                   \"Interlab-LC-MS_Lab2_M_Pos_MS2_Rep1.mzML\",                   \"Interlab-LC-MS_Lab2_M_Pos_MS2_Rep2.mzML\",                   \"Interlab-LC-MS_Lab2_M_Pos_MS2_Rep3.mzML\",                   \"Interlab-LC-MS_Lab2_PPL_Pos_MS2_Rep1.mzML\"),     sample_name = c(rep(\"A15M\", 3), rep(\"A45M\", 3), rep(\"A5M\", 3),                     rep(\"M\", 3), \"PPL\"),     sample_desc = c(\"A15M_R1\", \"A15M_R2\", \"A15M_R3\", \"A45M_R1\", \"A45M_R2\",                     \"A45M_R3\",                     \"A5M_R1\", \"A5M_R2\", \"A5M_R3\", \"M_R1\", \"M_R2\", \"M_R3\"                     , \"PPL_R1\"),     replicate = c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1) )  # Set path (Adjust this to your local folder!) # These files were downloaded from the MassIVE ftp server. path <- file.path(\"/data\", \"massive-ftp.ucsd.edu\", \"v04\", \"MSV000090156\",                    \"peak\", \"mzml\", \"POS_MSMS\", \"Lab_2\")  # Load data mse <- readMsExperiment(file.path(path, pd$file_name), sampleData = pd)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"initial-quality-control-and-filtering","dir":"Articles","previous_headings":"","what":"Initial quality control and filtering","title":"Workshop: xcms preprocessing for GNPS2","text":"processing, check Base Peak Chromatogram (BPC) ensure chromatography looks good identify empty time range.  Base Peak Chromatogram (BPC) samples retention time filtering. chromatography empty 20s 850s. filter dataset reduce processing time. can check :  Base Peak Chromatogram (BPC) samples retention time filtering. BPC TIC aggregate data along m/z dimension per spectrum (retention time) compare signal measured along retention time. compare mass ion content individual samples/measurement runs addition aggregate data along retention time, distinct m/z values. thus single aggregated mass spectrum per sample. base peak spectra plotted .  can also use aggregated spectra calculate spectra similarity individual samples cluster .  Similarity base peak spectra samples experiment. A15M, A5M M samples cluster together, separately A45M samples PPL_R1 sample distinct mass peak profile.","code":"# Define colors for plotting col <- brewer.pal(length(unique(pd$sample_name)), \"Set2\") names(col) <- unique(pd$sample_name) col_sample <- col[pd$sample_name]  # Plot BPC bpc <- chromatogram(mse, aggregationFun = \"max\") plot(bpc, col = paste0(col_sample, 80), main = \"BPC (Raw)\", lwd = 2) legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) mse <- filterSpectra(mse, filterRt, c(20, 850)) # Plot BPC bpc <- chromatogram(mse, aggregationFun = \"max\") plot(bpc, col = paste0(col_sample, 80), main = \"BPC (Raw)\", lwd = 2) legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) #' bin mass peaks into into discrete m/z bins of 0.02 Da. s_bin <- spectra(mse) |>     filterMsLevel(1L) |>     bin(binSize = 0.02)  #' combine all spectra within the same sample into a single spectrum #' reporting the maximum intensity of all mass peaks with the same m/z bin bps <- combineSpectra(s_bin, f = s_bin$dataOrigin, intensityFun = max) Backend of the input object is read-only, will change that to an 'MsBackendMemory' plotSpectraOverlay(bps, col = paste0(col_sample, 40), lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1) sim <- compareSpectra(bps) rownames(sim) <- colnames(sim) <- sampleData(mse)$sample_desc pheatmap(sim)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"peak-detection-centwave","dir":"Articles","previous_headings":"","what":"Peak Detection (CentWave)","title":"Workshop: xcms preprocessing for GNPS2","text":"use CentWave algorithm. key parameters needs adapted dataset : peakwidth: range widths (seconds) chromatographic peak. ppm: Defines maximum allowed deviation m/z dimension mass peaks consecutive spectra considered represent signal ion. define need evaluate raw data.  Definition example region EIC extraction. Upper panel: BPC, dashed vertical lines indicate selected retention time region. Lower panel: EIC m/z region largest signal retention time window. width chromatographic peaks 8 seconds. evaluate second signal end chromatogram.  Definition example region EIC extraction. Upper panel: BPC, dashed vertical lines indicate selected retention time region. Lower panel: EIC m/z region largest signal retention time window. width chromatographic peaks m/z slice seem around 15 seconds. Also, seems considerable shift retention times samples. set peak width :  individual mass peaks shown lower panel plot . present ion, m/z values show low variance. evaluate signal also second m/z - retention time window defined .  scattering m/z values looks larger, still 0.001 Da. nevertheless use ppm = 20 present data set - assume ions different compounds elute time difference ppm lower 20. Now can run peak detection CentWave. cases also advisable perform peak postprocessing remove artifacts centWave peak detection (e.g. overlapping split peaks). can check results example EICs:  EICs detected chromatographic peaks indicated. Compare number identified peaks per sample well m/z retention time widths.","code":"#' extract BPC par(mfrow = c(2, 1)) bpc <- chromatogram(mse, aggregationFun = \"max\") plot(bpc, col = paste0(col_sample, 80), lwd = 2) grid()  #' identify a retention time region to extract rtr_1 <- c(105, 130) abline(v = rtr_1, lty = 2)  #' identify the m/z with the largest intensity in that region: #' - restrict to MS1 data #' - filter the MS data by retention time #' - extract the MS data as a data.frame tmp <- spectra(mse) |>     filterMsLevel(1L) |>     filterRt(rtr_1) |>     longForm(columns = c(\"mz\", \"intensity\"))  #' define a m/z range around the m/z with largest intensity mzr_1 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)  #' extract an EIC for that RT and m/z region eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1) plot(eic_1, col = paste0(col_sample, 80), lwd = 2) grid() par(mfrow = c(2, 1)) plot(bpc, col = paste0(col_sample, 80), lwd = 2) grid()  #' identify a region to extract rtr_2 <- c(720, 770) abline(v = rtr_2, lty = 2)  #' identify the m/z with the largest intensity in that region: #' - restrict to MS1 data #' - filter the MS data by retention time #' - extract the MS data as a data.frame tmp <- spectra(mse) |>     filterMsLevel(1L) |>     filterRt(rtr_2) |>     longForm(columns = c(\"mz\", \"intensity\"))  #' define a m/z range around the m/z with largest intensity mzr_2 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)  #' extract an EIC for that RT and m/z region eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2) plot(eic_2, col = paste0(col_sample, 80), lwd = 2) grid() set_pw <- c(5,20) # peakwidth in seconds mse[1L] |>     filterSpectra(filterMsLevel, 1L) |>     filterSpectra(filterRt, rt = rtr_1) |>     filterSpectra(filterMzRange, mz = mzr_1) |>     plot() mse[1L] |>     filterSpectra(filterMsLevel, 1L) |>     filterSpectra(filterRt, rt = rtr_2) |>     filterSpectra(filterMzRange, mz = mzr_2) |>     plot() set_ppm <- 20 # Configure CentWave cwp <- CentWaveParam(     ppm = set_ppm,      peakwidth = set_pw,     snthresh = 8,      mzdiff = 0.001 )  # Run Peak Detection mse <- findChromPeaks(mse, param = cwp, chunkSize = nb_cores) # Optional: Refine peaks (merge split peaks) mse <- refineChromPeaks(mse, MergeNeighboringPeaksParam(expandRt = 1,                                                          minProp = 0.75),                         chunkSize = nb_cores) Reduced from 105113 to 93968 chromatographic peaks. eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1) eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2)  par(mfrow = c(2, 1)) plot(eic_1, col = paste0(col_sample, 80), lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_2, col = paste0(col_sample, 80), lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) #' split the detected chrom peaks per sample pk_list <- split.data.frame(     chromPeaks(mse, columns = c(\"mzmin\", \"mzmax\", \"rtmin\", \"rtmax\")),     chromPeaks(mse, columns = \"sample\")[, \"sample\"]) #' calculate mz and rt widths pk_list <- lapply(pk_list, function(z) {     cbind(z, mz_width = z[, \"mzmax\"] - z[, \"mzmin\"],           mz_width_ppm = (z[, \"mzmax\"] - z[, \"mzmin\"]) * 1e6 / z[, \"mzmax\"],           rt_width = z[, \"rtmax\"] - z[, \"rtmin\"]) })  #' plot the information par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1)) barplot(unlist(lapply(pk_list, nrow)),      col = col_sample,      ylab = \"peak count\", main = \"Peak detection summary, mse\", xaxt = \"n\") grid() legend(\"top\", horiz = TRUE, col = col, pch = 15,        legend = names(col)) par(mar = c(0, 4.3, 0, 0.1)) vioplot(lapply(pk_list, function(z) z[, \"mz_width_ppm\"]), outline = FALSE,         ylab = \"m/z width [ppm]\", xaxt = \"n\", line = 3,         col = col_sample) grid() vioplot(lapply(pk_list, function(z) z[, \"rt_width\"]),         ylab = \"rt width [s]\", col = col_sample, line = 3) grid()"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"peak-width-setup","dir":"Articles","previous_headings":"","what":"peak-width setup","title":"Workshop: xcms preprocessing for GNPS2","text":"define need evaluate raw data.  Definition example region EIC extraction. Upper panel: BPC, dashed vertical lines indicate selected retention time region. Lower panel: EIC m/z region largest signal retention time window. width chromatographic peaks 8 seconds. evaluate second signal end chromatogram.  Definition example region EIC extraction. Upper panel: BPC, dashed vertical lines indicate selected retention time region. Lower panel: EIC m/z region largest signal retention time window. width chromatographic peaks m/z slice seem around 15 seconds. Also, seems considerable shift retention times samples. set peak width :","code":"#' extract BPC par(mfrow = c(2, 1)) bpc <- chromatogram(mse, aggregationFun = \"max\") plot(bpc, col = paste0(col_sample, 80), lwd = 2) grid()  #' identify a retention time region to extract rtr_1 <- c(105, 130) abline(v = rtr_1, lty = 2)  #' identify the m/z with the largest intensity in that region: #' - restrict to MS1 data #' - filter the MS data by retention time #' - extract the MS data as a data.frame tmp <- spectra(mse) |>     filterMsLevel(1L) |>     filterRt(rtr_1) |>     longForm(columns = c(\"mz\", \"intensity\"))  #' define a m/z range around the m/z with largest intensity mzr_1 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)  #' extract an EIC for that RT and m/z region eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1) plot(eic_1, col = paste0(col_sample, 80), lwd = 2) grid() par(mfrow = c(2, 1)) plot(bpc, col = paste0(col_sample, 80), lwd = 2) grid()  #' identify a region to extract rtr_2 <- c(720, 770) abline(v = rtr_2, lty = 2)  #' identify the m/z with the largest intensity in that region: #' - restrict to MS1 data #' - filter the MS data by retention time #' - extract the MS data as a data.frame tmp <- spectra(mse) |>     filterMsLevel(1L) |>     filterRt(rtr_2) |>     longForm(columns = c(\"mz\", \"intensity\"))  #' define a m/z range around the m/z with largest intensity mzr_2 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)  #' extract an EIC for that RT and m/z region eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2) plot(eic_2, col = paste0(col_sample, 80), lwd = 2) grid() set_pw <- c(5,20) # peakwidth in seconds mse[1L] |>     filterSpectra(filterMsLevel, 1L) |>     filterSpectra(filterRt, rt = rtr_1) |>     filterSpectra(filterMzRange, mz = mzr_1) |>     plot()"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"ppm-setup","dir":"Articles","previous_headings":"","what":"ppm setup","title":"Workshop: xcms preprocessing for GNPS2","text":"individual mass peaks shown lower panel plot . present ion, m/z values show low variance. evaluate signal also second m/z - retention time window defined .  scattering m/z values looks larger, still 0.001 Da. nevertheless use ppm = 20 present data set - assume ions different compounds elute time difference ppm lower 20. Now can run peak detection CentWave. cases also advisable perform peak postprocessing remove artifacts centWave peak detection (e.g. overlapping split peaks). can check results example EICs:  EICs detected chromatographic peaks indicated.","code":"mse[1L] |>     filterSpectra(filterMsLevel, 1L) |>     filterSpectra(filterRt, rt = rtr_2) |>     filterSpectra(filterMzRange, mz = mzr_2) |>     plot() set_ppm <- 20 # Configure CentWave cwp <- CentWaveParam(     ppm = set_ppm,      peakwidth = set_pw,     snthresh = 8,      mzdiff = 0.001 )  # Run Peak Detection mse <- findChromPeaks(mse, param = cwp, chunkSize = nb_cores) # Optional: Refine peaks (merge split peaks) mse <- refineChromPeaks(mse, MergeNeighboringPeaksParam(expandRt = 1,                                                          minProp = 0.75),                         chunkSize = nb_cores) Reduced from 105113 to 93968 chromatographic peaks. eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1) eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2)  par(mfrow = c(2, 1)) plot(eic_1, col = paste0(col_sample, 80), lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_2, col = paste0(col_sample, 80), lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"evaluate-peak-picking","dir":"Articles","previous_headings":"","what":"Evaluate peak-picking","title":"Workshop: xcms preprocessing for GNPS2","text":"Compare number identified peaks per sample well m/z retention time widths.","code":"#' split the detected chrom peaks per sample pk_list <- split.data.frame(     chromPeaks(mse, columns = c(\"mzmin\", \"mzmax\", \"rtmin\", \"rtmax\")),     chromPeaks(mse, columns = \"sample\")[, \"sample\"]) #' calculate mz and rt widths pk_list <- lapply(pk_list, function(z) {     cbind(z, mz_width = z[, \"mzmax\"] - z[, \"mzmin\"],           mz_width_ppm = (z[, \"mzmax\"] - z[, \"mzmin\"]) * 1e6 / z[, \"mzmax\"],           rt_width = z[, \"rtmax\"] - z[, \"rtmin\"]) })  #' plot the information par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1)) barplot(unlist(lapply(pk_list, nrow)),      col = col_sample,      ylab = \"peak count\", main = \"Peak detection summary, mse\", xaxt = \"n\") grid() legend(\"top\", horiz = TRUE, col = col, pch = 15,        legend = names(col)) par(mar = c(0, 4.3, 0, 0.1)) vioplot(lapply(pk_list, function(z) z[, \"mz_width_ppm\"]), outline = FALSE,         ylab = \"m/z width [ppm]\", xaxt = \"n\", line = 3,         col = col_sample) grid() vioplot(lapply(pk_list, function(z) z[, \"rt_width\"]),         ylab = \"rt width [s]\", col = col_sample, line = 3) grid()"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"alignment-retention-time-correction","dir":"Articles","previous_headings":"","what":"Alignment (Retention time correction)","title":"Workshop: xcms preprocessing for GNPS2","text":"align samples using “Anchor Peaks” (peaks present samples). Group: First, group peaks loosely find “anchor peaks.” Align: calculate shift adjust RT. test important parameters, eics: bw: bandwidth density estimation peak retention times minFraction: minimum fraction samples peak must present considered anchor peak.  Correspondence analysis simulation second example EIC. used settings, particular parameter bw, present chromatographic peaks split two separate LC-MS features (indicated grey rectangle lower panel).  larger bandwidth, chromatographic peaks grouped single feature (grey rectangle). thus set bw = 7 present data set need pay attention following parameters: minFraction: minimum fraction samples peak must present considered anchor peak. span: smoothing parameter retention time correction function.Values 0.5 usually work case testing needed go low 0.1  Retention time alignment results.. stronger alignment can observed retention time area 750 800 seconds. evaluate also based chosen eics:  EICs retention time alignment first example regions.  EICs retention time alignment second example regions. Note cases necessary samples perfectly aligned. variation retention time can accounted final correspondence analysis.","code":"pdp <- PeakDensityParam(     sampleGroups = rep(1, length(mse)),     bw = 2,     minFraction = 0.2,     binSize = 0.01,     ppm = 10)  col_peak <- col_sample[chromPeaks(eic_2)[, \"sample\"]] plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 7 plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() #' perform initial correspondence analysis to group chromatographic peaks mse <- groupChromPeaks(mse, param = pdp) #' configure and run retention time alignment pgp <- PeakGroupsParam(     minFraction = 0.90,     span = 0.1) mse <- adjustRtime(mse, param = pgp) Performing retention time alignment using 898 anchor peaks. Warning: Adjusted retention times had to be re-adjusted for some files to ensure them being in the same order than the raw retention times. A call to 'dropAdjustedRtime' might thus fail to restore retention times of chromatographic peaks to their original values. Eventually consider to increase the value of the 'span' parameter. #' visualize alignment results plotAdjustedRtime(mse, col = paste0(col_sample, 80),                   peakGroupsPch = 21, lwd = 2) grid() legend(\"topleft\", col = col, lty = 1,        legend = names(col)) eic_1_adj <- chromatogram(mse, rt = rtr_1, mz = mzr_1) Extracting chromatographic data Processing chromatographic peaks par(mfrow = c(2, 1)) #' Setting peakType = \"none\" prevents identified chromatographic peaks to be #' indicated in the plot. plot(eic_1, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_1_adj, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() eic_2_adj <- chromatogram(mse, rt = rtr_2, mz = mzr_2) Extracting chromatographic data Processing chromatographic peaks par(mfrow = c(2, 1)) plot(eic_2, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_2_adj, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid()"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"initial-correspondence-analysis","dir":"Articles","previous_headings":"","what":"Initial correspondence analysis","title":"Workshop: xcms preprocessing for GNPS2","text":"test important parameters, eics: bw: bandwidth density estimation peak retention times minFraction: minimum fraction samples peak must present considered anchor peak.  Correspondence analysis simulation second example EIC. used settings, particular parameter bw, present chromatographic peaks split two separate LC-MS features (indicated grey rectangle lower panel).  larger bandwidth, chromatographic peaks grouped single feature (grey rectangle). thus set bw = 7 present data set","code":"pdp <- PeakDensityParam(     sampleGroups = rep(1, length(mse)),     bw = 2,     minFraction = 0.2,     binSize = 0.01,     ppm = 10)  col_peak <- col_sample[chromPeaks(eic_2)[, \"sample\"]] plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 7 plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() #' perform initial correspondence analysis to group chromatographic peaks mse <- groupChromPeaks(mse, param = pdp)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"rt-alignment-using-peak-group","dir":"Articles","previous_headings":"","what":"RT alignment using peak group","title":"Workshop: xcms preprocessing for GNPS2","text":"need pay attention following parameters: minFraction: minimum fraction samples peak must present considered anchor peak. span: smoothing parameter retention time correction function.Values 0.5 usually work case testing needed go low 0.1  Retention time alignment results.. stronger alignment can observed retention time area 750 800 seconds. evaluate also based chosen eics:  EICs retention time alignment first example regions.  EICs retention time alignment second example regions. Note cases necessary samples perfectly aligned. variation retention time can accounted final correspondence analysis.","code":"#' configure and run retention time alignment pgp <- PeakGroupsParam(     minFraction = 0.90,     span = 0.1) mse <- adjustRtime(mse, param = pgp) Performing retention time alignment using 898 anchor peaks. Warning: Adjusted retention times had to be re-adjusted for some files to ensure them being in the same order than the raw retention times. A call to 'dropAdjustedRtime' might thus fail to restore retention times of chromatographic peaks to their original values. Eventually consider to increase the value of the 'span' parameter. #' visualize alignment results plotAdjustedRtime(mse, col = paste0(col_sample, 80),                   peakGroupsPch = 21, lwd = 2) grid() legend(\"topleft\", col = col, lty = 1,        legend = names(col)) eic_1_adj <- chromatogram(mse, rt = rtr_1, mz = mzr_1) Extracting chromatographic data Processing chromatographic peaks par(mfrow = c(2, 1)) #' Setting peakType = \"none\" prevents identified chromatographic peaks to be #' indicated in the plot. plot(eic_1, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_1_adj, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() eic_2_adj <- chromatogram(mse, rt = rtr_2, mz = mzr_2) Extracting chromatographic data Processing chromatographic peaks par(mfrow = c(2, 1)) plot(eic_2, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_2_adj, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid()"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"feature-definition","dir":"Articles","previous_headings":"","what":"Feature Definition","title":"Workshop: xcms preprocessing for GNPS2","text":"Now RT aligned, perform final grouping peaks “Features”. require feature present least 67% replicates within sample group (.e., 2 3), precised sampleGroups parameter. now leave bw parameter 7. now check problematic second eic :  Simulation correspondence analysis second example EIC. nicely grouped feature side peak included . However check complex part data:  Simulation correspondence analysis expanded RT window.. separating features properly. Let’s try smaller bw:  Simulation correspondence analysis expanded RT window smaller bw. now successfully group signals distinct features. thus set bw = 3 final feature definition. Checking results overall data processing important algorithms behave differently eics full data.  Correspondence results m/z slice multiple closely eluting compounds. large number mainly explain low minFraction parameter used. required chromatographic peak detected 2 3 replicates individual sample define, combine , feature.","code":"#' configure the *peak density* correspondence method pdp <- PeakDensityParam(     sampleGroups = sampleData(mse)$sample_name,     minFraction = 0.67,     binSize = 0.01,     ppm = 10,     bw = 7) col_peak <- col_sample[chromPeaks(eic_2_adj)[, \"sample\"]] plotChromPeakDensity(eic_2_adj, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() a <- chromatogram(mse, mz = mzr_1, rt = c(30, 150)) Extracting chromatographic data Processing chromatographic peaks col_peak <- col_sample[chromPeaks(a)[, \"sample\"]] plotChromPeakDensity(a, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 3 plotChromPeakDensity(a, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() #' perform correspondence analysis on the full data set mse <- groupChromPeaks(mse, param = pdp) a <- chromatogram(mse, mz = mzr_1, rt = c(30, 150)) Extracting chromatographic data Processing chromatographic peaks Processing features col_peak <- col_sample[chromPeaks(a)[, \"sample\"]] plotChromPeakDensity(a, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40),                      simulate = FALSE) grid() # Check feature table size cat(\"Defined Features:\", nrow(featureDefinitions(mse))) Defined Features: 14313"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"gap-filling","dir":"Articles","previous_headings":"","what":"Gap-filling","title":"Workshop: xcms preprocessing for GNPS2","text":"can now extract abundance estimates features featureValues() function.  Number missing values per sample feature definition. present data set large number missing values. missing value indicates failure detect chromatographic peak m/z - retention time region feature sample. can multiple reasons: compound might simply present sample original signal noisy, low abundance, fit expected shape peak detection algorithm identify chromatographic peak. Gap filling check samples missing value feature (.e., chromatographic peak detected) integrate intensities measured within m/z - retention time area feature. extract feature values determine number missing values.  Number missing values per sample gap-filling. considerable amount values thus rescued.","code":"fvals <- featureValues(mse, method = \"sum\") colnames(fvals) <- sampleData(mse)$sample_desc  #' determine the number of missing values per sample and plot them nas <- apply(fvals, MARGIN = 2, function(z) sum(is.na(z)))  barplot(nas, main = \"Number of missing values\", col = col_sample) #' configure and perform gap-filling cpap <- ChromPeakAreaParam(minMzWidthPpm = 10) mse <- fillChromPeaks(mse, param = cpap, chunkSize = nb_cores) fvals <- featureValues(mse, method = \"sum\") colnames(fvals) <- sampleData(mse)$sample_desc  #' determine the number of missing values per sample and plot them nas <- apply(fvals, MARGIN = 2, function(z) sum(is.na(z))) barplot(nas, main = \"Number of missing values (after gap-filling)\",         col = col_sample)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"ms2-assignment-export-for-gnps","dir":"Articles","previous_headings":"","what":"MS2 Assignment & Export for GNPS","title":"Workshop: xcms preprocessing for GNPS2","text":"associate MS2 spectra features just defined create consensus spectrum feature Note Spectra package provide many additional functions options process, scale clean spectra. alternative, SpectriPy package, also possible apply Python-based functionality e.g. matchms Python library Spectra objects. last visualize select data (.e. features associated MS2 spectra) m/z - retention time space.  Feature areas (grey rectangles) associated MS2 spectra (blue points) retention time - m/z space. Finally, export two files required GNPS FBMN. 2 files can now uploaded GNPS2 FBMN analysis.","code":"# 1. Extract MS2 associated with features ms2 <- featureSpectra(mse)  # 2. Combine into Consensus Spectra # Keep peaks present in at least 75% of spectra for that feature ms2_cons <- combineSpectra(ms2, f = ms2$feature_id, peaks = \"intersect\",                             minProp = 0.75, ppm = 10) Backend of the input object is read-only, will change that to an 'MsBackendMemory' # 3. Clean up (remove spectra with < 2 peaks) ms2_cons <- ms2_cons[lengths(ms2_cons) > 1] #' define the feature boundaries fa <- featureArea(mse, features = ms2_cons$feature_id)  #' plot feature areas as rectangles plot(NA, NA, xlim = range(fa[, c(\"rtmin\", \"rtmax\")]),      ylim = range(fa[, c(\"mzmin\", \"mzmax\")]),      xlab = \"retention time\", ylab = \"m/z\") grid() rect(xleft = fa[, \"rtmin\"], xright = fa[, \"rtmax\"],      ybottom = fa[, \"mzmin\"], ytop = fa[, \"mzmax\"],      border = \"#00000080\") #' add precursor m/z and retention times of MS2 points(ms2_cons$rtime, ms2_cons$precursorMz,        cex = 0.5, col = \"#0000ff40\") # EXPORT 1: Feature Table (Quantification) fvals <- featureValues(mse, method = \"sum\") colnames(fvals) <- sampleData(mse)$sample_desc  # Get feature metadata (m/z, RT) fdef <- featureDefinitions(mse)[, c(\"mzmed\", \"rtmed\")] fvals_export <- cbind(Row.names = rownames(fdef), fdef, fvals)  # Filter to only features that actually have MS2 spectra fvals_export <- fvals_export[ms2_cons$feature_id, ]  write.table(fvals_export, \"xcms_ms2_features.txt\", sep = \"\\t\", quote = FALSE,             row.names = FALSE)  # EXPORT 2: MGF File (Spectra) # Helper function to format for GNPS source(\"https://raw.githubusercontent.com/jorainer/xcms-gnps-tools/master/customFunctions.R\") ms2_cons_gnps <- formatSpectraForGNPS(ms2_cons)  export(ms2_cons_gnps, backend = MsBackendMgf(), file = \"xcms_ms2_spectra.mgf\")"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"additional-spectra-processing-options","dir":"Articles","previous_headings":"","what":"Additional spectra processing options","title":"Workshop: xcms preprocessing for GNPS2","text":"Note Spectra package provide many additional functions options process, scale clean spectra. alternative, SpectriPy package, also possible apply Python-based functionality e.g. matchms Python library Spectra objects. last visualize select data (.e. features associated MS2 spectra) m/z - retention time space.  Feature areas (grey rectangles) associated MS2 spectra (blue points) retention time - m/z space. Finally, export two files required GNPS FBMN. 2 files can now uploaded GNPS2 FBMN analysis.","code":"#' define the feature boundaries fa <- featureArea(mse, features = ms2_cons$feature_id)  #' plot feature areas as rectangles plot(NA, NA, xlim = range(fa[, c(\"rtmin\", \"rtmax\")]),      ylim = range(fa[, c(\"mzmin\", \"mzmax\")]),      xlab = \"retention time\", ylab = \"m/z\") grid() rect(xleft = fa[, \"rtmin\"], xright = fa[, \"rtmax\"],      ybottom = fa[, \"mzmin\"], ytop = fa[, \"mzmax\"],      border = \"#00000080\") #' add precursor m/z and retention times of MS2 points(ms2_cons$rtime, ms2_cons$precursorMz,        cex = 0.5, col = \"#0000ff40\") # EXPORT 1: Feature Table (Quantification) fvals <- featureValues(mse, method = \"sum\") colnames(fvals) <- sampleData(mse)$sample_desc  # Get feature metadata (m/z, RT) fdef <- featureDefinitions(mse)[, c(\"mzmed\", \"rtmed\")] fvals_export <- cbind(Row.names = rownames(fdef), fdef, fvals)  # Filter to only features that actually have MS2 spectra fvals_export <- fvals_export[ms2_cons$feature_id, ]  write.table(fvals_export, \"xcms_ms2_features.txt\", sep = \"\\t\", quote = FALSE,             row.names = FALSE)  # EXPORT 2: MGF File (Spectra) # Helper function to format for GNPS source(\"https://raw.githubusercontent.com/jorainer/xcms-gnps-tools/master/customFunctions.R\") ms2_cons_gnps <- formatSpectraForGNPS(ms2_cons)  export(ms2_cons_gnps, backend = MsBackendMgf(), file = \"xcms_ms2_spectra.mgf\")"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Workshop: xcms preprocessing for GNPS2","text":"R-based data analysis workflows allow data set specific, tailored, analysis LC-MS data. xcms R package LC-MS data preprocessing tightly integrated broader ecosystem R packages. quarto system also allow combining R Python functionality workflow document SpectriPy R-package translating R Python MS data structures.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing-condensed.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Workshop: xcms preprocessing for GNPS2","text":"","code":"sessionInfo() R version 4.5.2 (2025-10-31) Platform: x86_64-pc-linux-gnu Running under: Ubuntu 24.04.3 LTS  Matrix products: default BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0  locale:  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C  [9] LC_ADDRESS=C               LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C  time zone: Etc/UTC tzcode source: system (glibc)  attached base packages: [1] stats4    stats     graphics  grDevices utils     datasets  methods [8] base  other attached packages:  [1] vioplot_0.5.1       zoo_1.8-14          sm_2.2-6.0  [4] pheatmap_1.0.13     RColorBrewer_1.1-3  MsBackendMgf_1.18.0  [7] xcms_4.8.0          Spectra_1.20.0      BiocParallel_1.44.0 [10] S4Vectors_0.48.0    BiocGenerics_0.56.0 generics_0.1.4 [13] MsExperiment_1.12.0 ProtGenerics_1.42.0  loaded via a namespace (and not attached):  [1] DBI_1.2.3                   rlang_1.1.6  [3] magrittr_2.0.4              clue_0.3-66  [5] MassSpecWavelet_1.76.0      matrixStats_1.5.0  [7] compiler_4.5.2              vctrs_0.6.5  [9] reshape2_1.4.5              stringr_1.6.0 [11] pkgconfig_2.0.3             MetaboCoreUtils_1.18.1 [13] crayon_1.5.3                fastmap_1.2.0 [15] XVector_0.50.0              rmarkdown_2.30 [17] preprocessCore_1.72.0       purrr_1.2.0 [19] xfun_0.54                   MultiAssayExperiment_1.36.1 [21] jsonlite_2.0.0              progress_1.2.3 [23] DelayedArray_0.36.0         parallel_4.5.2 [25] prettyunits_1.2.0           cluster_2.1.8.1 [27] R6_2.6.1                    stringi_1.8.7 [29] limma_3.66.0                GenomicRanges_1.62.0 [31] Rcpp_1.1.0                  Seqinfo_1.0.0 [33] SummarizedExperiment_1.40.0 iterators_1.0.14 [35] knitr_1.50                  IRanges_2.44.0 [37] BiocBaseUtils_1.12.0        Matrix_1.7-4 [39] igraph_2.2.1                tidyselect_1.2.1 [41] abind_1.4-8                 yaml_2.3.12 [43] doParallel_1.0.17           codetools_0.2-20 [45] affy_1.88.0                 lattice_0.22-7 [47] tibble_3.3.0                plyr_1.8.9 [49] Biobase_2.70.0              S7_0.2.1 [51] evaluate_1.0.5              pillar_1.11.1 [53] affyio_1.80.0               BiocManager_1.30.27 [55] MatrixGenerics_1.22.0       foreach_1.5.2 [57] MSnbase_2.36.0              MALDIquant_1.22.3 [59] ncdf4_1.24                  hms_1.1.4 [61] ggplot2_4.0.1               scales_1.4.0 [63] glue_1.8.0                  MsFeatures_1.18.0 [65] lazyeval_0.2.2              tools_4.5.2 [67] mzID_1.48.0                 data.table_1.17.8 [69] QFeatures_1.20.0            vsn_3.78.0 [71] mzR_2.44.0                  fs_1.6.6 [73] XML_3.99-0.20               grid_4.5.2 [75] impute_1.84.0               tidyr_1.3.1 [77] MsCoreUtils_1.22.1          PSMatch_1.14.0 [79] cli_3.6.5                   S4Arrays_1.10.1 [81] dplyr_1.1.4                 AnnotationFilter_1.34.0 [83] pcaMethods_2.2.0            gtable_0.3.6 [85] digest_0.6.39               SparseArray_1.10.6 [87] farver_2.1.2                htmltools_0.5.9 [89] lifecycle_1.0.4             statmod_1.5.1 [91] MASS_7.3-65"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"document describes data inspection preprocessing LC-MS/MS data set using xcms (Louail, Brunius, et al. 2025) export data subsequent feature-based molecular networking (FBMN) GNPS2. Functionality different packages RforMassSpectrometry package ecosystem combined visualize process data. details depth description various visualizations analysis options well parameter choices see also Metabonaut tutorials (Louail, Graeve, et al. 2025). analysis used settings considered initial potential refinement improvement based discussions expected integration analysis FBMN workflow.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"required-software-packages","dir":"Articles","previous_headings":"","what":"Required software packages","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"various software packages required analysis defined loaded . packages available Bioconductor CRAN can installed BiocManager::install(<package name>).","code":"library(MsExperiment) # container for MS data library(Spectra)      # main MS infrastructure for R library(xcms)         # for preprocessing of LC-MS and LC-MS/MS data library(MsBackendMgf) # to export MS data in MGF format  library(RColorBrewer) # to define colors library(pander)       # to format tables library(pheatmap)     # visualization of clustering results as heatmap library(vioplot)      # to create *violin plots*"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"data-import","dir":"Articles","previous_headings":"","what":"Data import","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"data analyzed part MassIVE MSV000090156 data set. full data set (raw data files) first downloaded respective directory ftp server: ftp://massive-ftp.ucsd.edu/v04/MSV000090156/. analyze data Lab 2. loading data define data.frame sample experiment-specific information individual MS runs/data files. ideally comprise relevant phenotypic also technical information (e.g. injection index) allow proper adjusting modeling data. run analysis MS data files (mzML format) need available. example workflow, downloaded MassIVE ftp server stored local folder /data/massive-ftp.ucsd.edu/v04. define path data files load data set. needs adapted files stored different folder. samples data files present data set displayed table . Note R code block use R pipe operator |> avoid nested function calls improve readability code. addition also define different colors individual samples.","code":"pd <- data.frame(     file_name = c(\"Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep1.mzML\",                   \"Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep2.mzML\",                   \"Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep3.mzML\",                   \"Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep1.mzML\",                   \"Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep2.mzML\",                   \"Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep3.mzML\",                   \"Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep1.mzML\",                   \"Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep2.mzML\",                   \"Interlab-LC-MS_Lab2_A5M_Pos_MS2_Rep3.mzML\",                   \"Interlab-LC-MS_Lab2_M_Pos_MS2_Rep1.mzML\",                   \"Interlab-LC-MS_Lab2_M_Pos_MS2_Rep2.mzML\",                   \"Interlab-LC-MS_Lab2_M_Pos_MS2_Rep3.mzML\",                   \"Interlab-LC-MS_Lab2_PPL_Pos_MS2_Rep1.mzML\"),     sample_name = c(\"A15M\", \"A15M\", \"A15M\",                     \"A45M\", \"A45M\", \"A45M\",                     \"A5M\", \"A5M\", \"A5M\",                     \"M\", \"M\", \"M\",                     \"PPL\"),     sample_desc = c(\"A15M_R1\", \"A15M_R2\", \"A15M_R3\",                     \"A45M_R1\", \"A45M_R2\", \"A45M_R3\",                     \"A5M_R1\", \"A5M_R2\", \"A5M_R3\",                     \"M_R1\", \"M_R2\", \"M_R3\",                     \"PPL_R1\"),     replicate = c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1) ) path <- file.path(\"/data\", \"massive-ftp.ucsd.edu\", \"v04\",                   \"MSV000090156\", \"peak\", \"mzml\", \"POS_MSMS\",                   \"Lab_2\") mse <- readMsExperiment(file.path(path, pd$file_name),                         sampleData = pd) mse Object of class MsExperiment  Spectra: MS1 (16302) MS2 (49500)  Experiment data: 13 sample(s)  Sample data links:   - spectra: 13 sample(s) to 65802 element(s). sampleData(mse)[, c(\"sample_name\", \"sample_desc\", \"replicate\")] |>     as.data.frame() |>     pandoc.table(style = \"rmarkdown\", split.table = Inf) #' Define a color for each unique original sample col <- sampleData(mse)$sample_name |>                      unique() |>                      length() |>                      brewer.pal(\"Set2\") names(col) <- unique(sampleData(mse)$sample_name)  #' Define a color for each data file/sample col_sample <- col[sampleData(mse)$sample_name]"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"data-visualization-and-general-quality-assessment","dir":"Articles","previous_headings":"","what":"Data visualization and general quality assessment","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"data inspection general data overview first create base peak chromatograms (BPC) total ion chromatograms (TIC) data set using chromatograms() functions specifying either \"max\" (BPC) \"sum\" (TIC) function aggregate per-spectrum intensities.   Based BPC TIC seems little retention time shifts samples. Also, signal seems present 20 seconds 850 seconds. Thus, filter data set spectra acquired within retention time range. BPC TIC aggregate data along m/z dimension per spectrum (retention time) compare signal measured along retention time. compare mass ion content individual samples/measurement runs addition aggregate data along retention time, distinct m/z values. end first bin spectrum get discrete similar m/z values within data set. thus single aggregated mass spectrum per sample. base peak spectra plotted .  Aggregated MS1 spectrum per sample. mass content samples seems similar, exception last file. can also plot spectra plot, using different color per sample.  can also use aggregated spectra calculate spectra similarity individual samples cluster .  Similarity base peak spectra samples experiment. A15M, A5M M samples cluster together, separately A45M samples PPL_R1 sample distinct mass peak profile.","code":"#' BPC bpc <- chromatogram(mse, aggregationFun = \"max\")  plot(bpc, col = paste0(col_sample, 80), main = \"BPC\", lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) #' TIC tic <- chromatogram(mse, aggregationFun = \"sum\")  plot(tic, col = paste0(col_sample, 80), main = \"TIC\", lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) #' filter the data set to a retention time range from 20 to 850 seconds mse <- filterSpectra(mse, filterRt, c(20, 850)) #' bin mass peaks into into discrete m/z bins of 0.02 Da. s_bin <- spectra(mse) |>     filterMsLevel(1L) |>     bin(binSize = 0.02)  #' combine all spectra within the same sample into a single spectrum #' reporting the maximum intensity of all mass peaks with the same m/z bin bps <- combineSpectra(s_bin, f = s_bin$dataOrigin, intensityFun = max) #' the same but reporting the sum of intensities per m/z bin tis <- combineSpectra(s_bin, f = s_bin$dataOrigin, intensityFun = sum) par(mar = c(4.5, 4, 0, 0.5)) plotSpectra(bps, main = \"\") plotSpectraOverlay(bps, col = paste0(col_sample, 40), lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1) sim <- compareSpectra(bps) rownames(sim) <- colnames(sim) <- sampleData(mse)$sample_desc pheatmap(sim)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"data-preprocessing","dir":"Articles","previous_headings":"","what":"Data preprocessing","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"Data preprocessing first step analysis LC-MS data processing analyzing raw MS data result two-dimensional quantification table LC-MS features various samples experiment. process consists 3 main steps: chromatographic peak detection, retention time alignment correspondence analysis. additional gap-filling step can conducted reduce number missing values integrating raw MS signal expected m/z retention time areas defined LC-MS features. methods xcms parallelized default. define parallel processing setup present analysis. Parallel processing details generally advisable configure parallel processing setup globally using register(). Unix machines multi-core parallel processing can used, shares memory parallel processes. Windows supports socket-based parallel processing starts separate R parallel process. globally define parallel processing setup depending operating system. present analysis use 4 parallel processes. aim chromatographic peak detection identify quantify signal raw MS data space representing signal ions compounds present sample. Data processing performed separately data file mass peak intensities similar m/z evaluated along retention time axis identify chromatographic peaks. use centWave algorithm peak detection. important parameter centWave peakwidth defines approximate lower upper expected width chromatographic peaks retention time dimension. Without prior information, need derive information data set. therefore zoom areas BPC seem contain signal ion.  Definition example region EIC extraction. Upper panel: BPC, dashed vertical lines indicate selected retention time region. Lower panel: EIC m/z region largest signal retention time window. width chromatographic peaks 8 seconds. evaluate second signal chromatogram.  Definition example region EIC extraction. Upper panel: BPC, dashed vertical lines indicate selected retention time region. Lower panel: EIC m/z region largest signal retention time window. width chromatographic peaks m/z slice seem around 15 seconds. Also, seems considerable shift retention times samples. Based two example signals define peakdwidth parameter present data set 5 20 seconds. real data analysis suggested evaluate signals, also eventually internal standards ions compounds expected present sample. second potentially data set-specific parameter centWave algorithm ppm. defines maximum allowed deviation m/z dimension mass peaks consecutive spectra considered represent signal ion. illustrate subset full MS data first data file m/z retention time range defined plot individual mass peaks. Details ppm centWave parameter ppm parameter defines expected (observed) m/z deviation mass peaks representing signal compound/ion consecutive spectra. scattering mass peak’s m/z values can depend centroiding algorithm used precision MS instrument. addition, TOF instruments, scattering can depend intensity signal, higher variation observed low intensity peaks increasing stability higher signal.  individual mass peaks shown lower panel plot . present ion, m/z values show low variance. evaluate signal also second m/z - retention time window defined .  scattering m/z values looks larger, still 0.001 Da. nevertheless use ppm = 20 present data set - assume ions different compounds elute time difference ppm lower 20. define settings centWave perform chromatographic peak detection full data set. Note can also helpful test different settings performing peak detection extracted ion chromatograms described Metabonaut. Parameter chunkSize defines number data files MS data loaded time. parameter thus influence memory usage analysis. cases also advisable perform peak postprocessing remove artifacts centWave peak detection (e.g. overlapping split peaks). perform peak refinement merge partially completely overlapping chromatographic peak, less 2 seconds apart , intensity apexes lower certain proportion apex intensity lower intensity peak. next compare number identified peaks per sample well m/z retention time widths.  highest number peaks detected PPL sample. Apart sample, numbers detected peaks comparable data set. Also m/z width retention time widths. expected, identified chromatographic peaks 10 seconds wide. Also, m/z width 10 ppm peaks, show also larger m/z widths. also evaluate peak detection results two example m/z - retention time regions. Identified chromatographic peaks colored according sample group.  Chromatographic peak detection results first example EIC.  Chromatographic peak detection results second example EIC. aim retention time alignment step reduce differences observed elution time compounds different LC-MS runs. variety methods proposed also implemented xcms. use straight forward approach aligns chromatographic runs based retention times anchor peaks, .e., compounds present samples experiment. define anchor peaks must however perform initial correspondence analysis group chromatographic peaks similar m/z retention time across samples. use peak density correspondence method groups chromatographic peaks LC-MS feature, m/z difference smaller binSize (+ ppm m/z), retention time apex within one peak peak density curve (smoothness can configured parameter bw) chromatographic peak present least minFraction least one sample groups defined sampleGroups. initial correspondence apply relaxed settings consider samples sample group (since want define anchor peaks present samples). Details PeakDensityParam settings peak density correspondence method can configured using PeakDensityParam. initial correspondence used retention time alignment relaxed settings can used, also putting samples sample group. important parameters bw binSize. former defines tolerance retention time similarity, latter similarity m/z values chromatographic peaks different samples considered represent signal ions compound. Setting binSize straight forward - depends resolution instrument expected similarity m/z values ion. set value binSize = 0.01, hence chromatographic peaks difference m/z smaller 0.01 evaluated. bw parameter bit difficult define. defined based observed data experiment, ideally, EICs closely eluting compounds m/z. example use second example m/z - retention time range, seemed contain signal compound, quite large shifts data files. simulate correspondence analysis EIC. parameters defined minFraction, defines minimum required proportion samples one sample groups defined parameter sampleGroups chromatographic peak present, ppm , together binSize defines maximal accepted difference chromatographic peaks’ m/z values consider grouping.  Correspondence analysis simulation second example EIC. upper panel plot shows EIC, lower panel data considered correspondence: shows retention time apex positions chromatographic peaks m/z slice x-axis sample chromatographic peak detected y-axis. black solid line represents peak density estimate, calculated based retention times chromatographic peaks parameter bw larger values bw resulting smooth curves. used settings, particular parameter bw, present chromatographic peaks split two separate LC-MS features (indicated grey rectangle lower panel). Assuming peaks region represent signal ions compound, however want group feature. hence next increase bw parameter simulate correspondence updated settings.  Correspondence analysis simulation bw = 5. Changing bw 5 changed density curve, still defined two separate features. thus increase bw 7.  Correspondence analysis simulation bw = 7. bw = 7 single feature defined. use parameter initial correspondence analysis full data set. retention time alignment use mentioned peak groups method aligns LC runs minimizing retention time differences called anchor peaks. alignment method robust also flexible, allowing example align samples based within-experiment QC samples, external reference data based manually defined anchor peaks. See Metabonaut examples options. method can configured PeakGroupsParam(). minFraction = 0.9 define anchor peaks LC-MS features (defined initial correspondence analysis) chromatographic peak identified 90% samples whole experiment. observed retention time differences used model curve along retention time dimension used align retention times samples. smoothness curve can configured parameter span (values 0 1; values around 0.5 work cases). effect alignment can visualized plotAdjustedRtime() function. plots adjusted retention times sample x-axis difference adjusted raw retention times y-axis solid line. Retention times anchor peaks sample indicated individual data points. ideally placed along full retention time range experiment.  Retention time alignment results. Anchor points span full retention time range. Retention time adjustments samples 2-4 seconds, exception 3 samples considerably larger adjustment present 500 seconds, PPL sample larger retention time differences 650 seconds. next evaluate alignment results based BPC alignment.  BPC (top) (bottom) retention time alignment. Misalignment signal later stage chromatography seems reduced. addition evaluate effect retention time alignment two example EICs.  First example EIC (top) (bottom) retention time alignment. early retention time range already raw signal well aligned.  Second example EIC (top) (bottom) retention time alignment. later retention time range shows clear, strong, differences retention times 4 samples. PPL sample aligned quite well using settings, 3 samples still show considerable shifts retention times. thus re-perform alignment reducing value span parameter switch local alignment samples. first undo retention time alignment, re-perform initial correspondence analysis perform alignment changed settings parameter span. Evaluating impact changing parameter.  Retention time alignment results. stronger alignment can observed retention time area 750 800 seconds. results first example EIC change.  First example EIC (top) (bottom) retention time alignment. second EIC alignment improved.  Second example EIC (top) (bottom) retention time alignment. Note cases necessary samples perfectly aligned. variation retention time can accounted final correspondence analysis. correspondence analysis groups chromatographic peaks different samples, assumed represent signal ions compound, LC-MS features. Signals generally grouped together based similarity m/z retention times. use peak density method , similarly previous section, first evaluate impact different parameter settings expected results. Also, final correspondence use samples’ sample_name parameter sampleGroup. Combined setting minFraction = 0.67, LC-MS feature defined chromatographic peak present least 67% replicates per sample (.e., 2 3). evaluate settings, particular effect bw first example EIC.  Simulation correspondence analysis first example EIC. EIC settings worked nicely. Simulating correspondence second example EIC.  Simulation correspondence analysis second example EIC. Also second EIC chromatographic peaks got grouped feature. Ideally, correspondence parameters also simulated complex signals, e.g. regions co- closely eluting compounds. expand retention time window m/z slice first example EIC.  Simulation correspondence analysis expanded RT window. seem signal 3 different compounds m/z slice. Using settings , particular bw = 7 apparently different chromatographic signals 105 115 seconds grouped LC-MS feature indicated grey rectangle plot . Unless want signals grouped together, need reduce value bw. simulate correspondence using bw = 3.  Effect changing bw = 3 correspondence analysis. bw = 3 successfully grouped signals 3 distinct features. next evaluate whether updated setting still group signal second example EIC single feature.  Effect bw = 3 correspondence results second example EIC. chromatographic peaks region grouped single region. thus proceed use settings correspondence analysis full data set. advised check results correspondence analysis, also evaluate impact settings like binSize ppm assure validity defined LC-MS features. Ideally, larger number EICs/features checked. extract first example EIC evaluate correspondence results . important set simulate = FALSE show actual results.  Correspondence results first example EIC. chromatographic peaks grouped feature. retention time (\"rtmed\") feature indicated dashed vertical line. next evaluate results also second example EIC.  Correspondence results second example EIC. Also retention time region, chromatographic peaks grouped single feature. last evaluate expanded retention time region m/z range first example EIC.  Correspondence results m/z slice multiple closely eluting compounds. region, chromatographic peaks grouped 3 distinct features. results correspondence analysis can extracted result object using featureDefinitions() featureValues() functions. former returns definition LC-MS features, .e., m/z retention time, latter actual abundance estimates different samples. count number features defined correspondence analysis: quite large number features defined. mostly due setting minFraction parameter, required chromatographic peak detected 2 3 replicates individual sample define, combine , feature. can now extract abundance estimates features featureValues() function. extract data matrix assign unique sample name column names (default MS data file name used). Columns abundance matrix samples, rows features. present data set large number missing values. missing value indicates failure detect chromatographic peak m/z - retention time region feature sample. can multiple reasons: compound might simply present sample original signal noisy, low abundance, fit expected shape peak detection algorithm identify chromatographic peak. calculate plot number missing values per sample.  Number missing feature values per sample. lowest number missing values present PPL_R1 sample. reduce number missing values avoid data imputation perform gap-filling: samples missing value feature (.e., chromatographic peak detected) integrate intensities measured within m/z - retention time area feature. default, area defined 25% 75% quantile lower, respectively upper m/z (retention time) boundary chromatographic peaks feature. example calculate area featureArea() function first 6 features: Thus, gap-filling, missing values replaced integrated signal measured MS instrument within m/z - retention time boundaries. perform gap-filling full data set. extract feature values determine number missing values.  Number missing feature values per sample gap-filling. considerable amount values thus rescued.","code":"if (.Platform$OS.type == \"unix\") {     register(MulticoreParam(4)) } else {     register(SnowParam(4)) } #' extract BPC par(mfrow = c(2, 1)) bpc <- chromatogram(mse, aggregationFun = \"max\") plot(bpc, col = paste0(col_sample, 80), lwd = 2) grid()  #' identify a retention time region to extract rtr_1 <- c(105, 130) abline(v = rtr_1, lty = 2)  #' identify the m/z with the largest intensity in that region: #' - restrict to MS1 data #' - filter the MS data by retention time #' - extract the MS data as a data.frame tmp <- spectra(mse) |>     filterMsLevel(1L) |>     filterRt(rtr_1) |>     longForm(columns = c(\"mz\", \"intensity\"))  #' define a m/z range around the m/z with largest intensity mzr_1 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)  #' extract an EIC for that RT and m/z region eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1) plot(eic_1, col = paste0(col_sample, 80), lwd = 2) grid() par(mfrow = c(2, 1)) plot(bpc, col = paste0(col_sample, 80), lwd = 2) grid()  #' identify a region to extract rtr_2 <- c(720, 770) abline(v = rtr_2, lty = 2)  #' identify the m/z with the largest intensity in that region: #' - restrict to MS1 data #' - filter the MS data by retention time #' - extract the MS data as a data.frame tmp <- spectra(mse) |>     filterMsLevel(1L) |>     filterRt(rtr_2) |>     longForm(columns = c(\"mz\", \"intensity\"))  #' define a m/z range around the m/z with largest intensity mzr_2 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)  #' extract an EIC for that RT and m/z region eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2) plot(eic_2, col = paste0(col_sample, 80), lwd = 2) grid() mse[1L] |>     filterSpectra(filterMsLevel, 1L) |>     filterSpectra(filterRt, rt = rtr_1) |>     filterSpectra(filterMzRange, mz = mzr_1) |>     plot() mse[1L] |>     filterSpectra(filterMsLevel, 1L) |>     filterSpectra(filterRt, rt = rtr_2) |>     filterSpectra(filterMzRange, mz = mzr_2) |>     plot() #' configure and perform chromatographic peak detection cwp <- CentWaveParam(     ppm = 20,     peakwidth = c(5, 20),     snthresh = 8,     integrate = 2,     mzdiff = 0.001 ) mse <- findChromPeaks(mse, param = cwp, chunkSize = 4L) #' configure and perform *peak refinement* mnpp <- MergeNeighboringPeaksParam(     expandRt = 1,     expandMz = 0,     ppm = 0,     minProp = 0.75) mse <- refineChromPeaks(mse, mnpp, chunkSize = 4L) #' split the detected chrom peaks per sample pk_list <- split.data.frame(     chromPeaks(mse, columns = c(\"mzmin\", \"mzmax\", \"rtmin\", \"rtmax\")),     chromPeaks(mse, columns = \"sample\")[, \"sample\"]) #' calculate mz and rt widths pk_list <- lapply(pk_list, function(z) {     cbind(z, mz_width = z[, \"mzmax\"] - z[, \"mzmin\"],           mz_width_ppm = (z[, \"mzmax\"] - z[, \"mzmin\"]) * 1e6 / z[, \"mzmax\"],           rt_width = z[, \"rtmax\"] - z[, \"rtmin\"]) })  #' plot the information par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1)) barplot(unlist(lapply(pk_list, nrow)),      col = col_sample,      ylab = \"peak count\", main = \"Peak detection summary, mse\", xaxt = \"n\") grid() legend(\"top\", horiz = TRUE, col = col, pch = 15,        legend = names(col)) par(mar = c(0, 4.3, 0, 0.1)) vioplot(lapply(pk_list, function(z) z[, \"mz_width_ppm\"]), outline = FALSE,         ylab = \"m/z width [ppm]\", xaxt = \"n\", line = 3,         col = col_sample) grid() vioplot(lapply(pk_list, function(z) z[, \"rt_width\"]),         ylab = \"rt width [s]\", col = col_sample, line = 3) grid() eic_1 <- chromatogram(mse, mz = mzr_1, rt = rtr_1)  #' define a color for each chromatographic peak col_peak <- col_sample[chromPeaks(eic_1)[, \"sample\"]] plot(eic_1, col = paste0(col_sample, 80),      peakBg = paste0(col_peak, 10),      peakCol = paste0(col_peak, 80)) grid() legend(\"topright\", col = col, lty = 1,        legend = names(col)) eic_2 <- chromatogram(mse, mz = mzr_2, rt = rtr_2)  #' define a color for each chromatographic peak col_peak <- col_sample[chromPeaks(eic_2)[, \"sample\"]] plot(eic_2, col = paste0(col_sample, 80),      peakBg = paste0(col_peak, 10),      peakCol = paste0(col_peak, 80)) grid() legend(\"topright\", col = col, lty = 1,        legend = names(col)) pdp <- PeakDensityParam(     sampleGroups = rep(1, length(mse)),     bw = 2,     minFraction = 0.2,     binSize = 0.01,     ppm = 10)  col_peak <- col_sample[chromPeaks(eic_2)[, \"sample\"]] plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 5 plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 7 plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() #' perform initial correspondence analysis to group chromatographic peaks mse <- groupChromPeaks(mse, param = pdp) #' configure and run retention time alignment pgp <- PeakGroupsParam(     minFraction = 0.90,     span = 0.4) mse <- adjustRtime(mse, param = pgp) #' visualize alignment results plotAdjustedRtime(mse, col = paste0(col_sample, 80),                   peakGroupsPch = 21, lwd = 2) grid() legend(\"topleft\", col = col, lty = 1,        legend = names(col)) #' create a BPC after adjustment; chromPeaks = \"none\" only creates the BPC #' without extracting also identified chromatographic peaks. bpc_adj <- chromatogram(mse, chromPeaks = \"none\", aggregationFun = \"max\")  par(mfrow = c(2, 1)) plot(bpc, col = paste0(col_sample, 80), main = \"BPC, raw\", lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(bpc_adj, col = paste0(col_sample, 80), main = \"BPC, adjusted\", lwd = 2) grid() eic_1_adj <- chromatogram(mse, rt = rtr_1, mz = mzr_1, chromPeaks = \"none\")  par(mfrow = c(2, 1)) plot(eic_1, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_1_adj, col = paste0(col_sample, 80), lwd = 2) grid() eic_2_adj <- chromatogram(mse, rt = rtr_2, mz = mzr_2, chromPeaks = \"none\")  par(mfrow = c(2, 1)) plot(eic_2, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_2_adj, col = paste0(col_sample, 80), lwd = 2) grid() #' remove retention time alignment results mse <- dropAdjustedRtime(mse) #' re-perform initial correspondence mse <- groupChromPeaks(mse, param = pdp) #' perform the alignment using updated settings pgp <- PeakGroupsParam(     minFraction = 0.90,     span = 0.1) mse <- adjustRtime(mse, param = pgp) #' visualize alignment results plotAdjustedRtime(mse, col = paste0(col_sample, 80),                   peakGroupsPch = 21, lwd = 2) grid() legend(\"topleft\", col = col, lty = 1,        legend = names(col)) eic_1_adj <- chromatogram(mse, rt = rtr_1, mz = mzr_1)  par(mfrow = c(2, 1)) #' Setting peakType = \"none\" prevents identified chromatographic peaks to be #' indicated in the plot. plot(eic_1, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_1_adj, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() eic_2_adj <- chromatogram(mse, rt = rtr_2, mz = mzr_2)  par(mfrow = c(2, 1)) plot(eic_2, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_2_adj, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() #' configure the *peak density* correspondence method pdp <- PeakDensityParam(     sampleGroups = sampleData(mse)$sample_name,     minFraction = 0.67,     binSize = 0.01,     ppm = 10,     bw = 7) col_peak <- col_sample[chromPeaks(eic_1_adj)[, \"sample\"]] plotChromPeakDensity(eic_1_adj, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() col_peak <- col_sample[chromPeaks(eic_2_adj)[, \"sample\"]] plotChromPeakDensity(eic_2_adj, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() a <- chromatogram(mse, mz = mzr_1, rt = c(30, 150))  col_peak <- col_sample[chromPeaks(a)[, \"sample\"]] plotChromPeakDensity(a, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 3 plotChromPeakDensity(a, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() col_peak <- col_sample[chromPeaks(eic_2_adj)[, \"sample\"]] plotChromPeakDensity(eic_2_adj, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() #' perform correspondence analysis on the full data set mse <- groupChromPeaks(mse, param = pdp) eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1)  #' plot the actual correspondence results by setting `simulate = FALSE` col_peak <- col_sample[chromPeaks(eic_1)[, \"sample\"]] plotChromPeakDensity(eic_1, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40),                      simulate = FALSE) grid() eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2)  #' plot the actual correspondence results by setting `simulate = FALSE` col_peak <- col_sample[chromPeaks(eic_2)[, \"sample\"]] plotChromPeakDensity(eic_2, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40),                      simulate = FALSE) grid() a <- chromatogram(mse, mz = mzr_1, rt = c(30, 150))  col_peak <- col_sample[chromPeaks(a)[, \"sample\"]] plotChromPeakDensity(a, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40),                      simulate = FALSE) grid() featureDefinitions(mse) |>     nrow() [1] 14808 fvals <- featureValues(mse, method = \"sum\") colnames(fvals) <- sampleData(mse)$sample_desc head(fvals) A15M_R1 A15M_R2 A15M_R3  A45M_R1 A45M_R2 A45M_R3  A5M_R1 A5M_R2 A5M_R3 FT00001      NA      NA      NA       NA      NA      NA      NA     NA     NA FT00002      NA      NA      NA       NA      NA      NA      NA     NA     NA FT00003      NA      NA      NA       NA      NA      NA      NA     NA     NA FT00004      NA 3392535      NA 10258668      NA 9478585 5519297     NA     NA FT00005      NA      NA      NA  9521460      NA 6722026 2419544     NA     NA FT00006      NA      NA      NA  4874998      NA 5897690 3338828     NA     NA            M_R1 M_R2 M_R3    PPL_R1 FT00001      NA   NA   NA  127518.4 FT00002      NA   NA   NA  201678.3 FT00003      NA   NA   NA  502676.9 FT00004 3684237   NA   NA 6198111.3 FT00005 3405333   NA   NA 2953772.8 FT00006      NA   NA   NA 6931111.8 #' determine the number of missing values per sample and plot them nas <- apply(fvals, MARGIN = 2, function(z) sum(is.na(z)))  barplot(nas, main = \"Number of missing values\", col = col_sample) featureArea(mse,             mzmin = function(z) quantile(z, probs = 0.25, na.rm = TRUE),             mzmax = function(z) quantile(z, probs = 0.75, na.rm = TRUE),             rtmin = function(z) quantile(z, probs = 0.25, na.rm = TRUE),             rtmax = function(z) quantile(z, probs = 0.75, na.rm = TRUE),             features = rownames(featureDefinitions(mse))[1:4]) mzmin    mzmax    rtmin    rtmax FT00001 150.0268 150.0270 588.3672 594.2322 FT00002 150.0789 150.0791 166.7511 175.2998 FT00003 150.0912 150.0916 245.4199 254.4996 FT00004 150.1022 150.1030 812.2422 837.7419 #' configure and perform gap-filling cpap <- ChromPeakAreaParam(minMzWidthPpm = 10) mse <- fillChromPeaks(mse, param = cpap, chunkSize = 4L) fvals <- featureValues(mse, method = \"sum\") colnames(fvals) <- sampleData(mse)$sample_desc head(fvals) A15M_R1   A15M_R2    A15M_R3  A45M_R1   A45M_R2   A45M_R3    A5M_R1 FT00001        NA        NA         NA       NA        NA        NA        NA FT00002        NA        NA         NA       NA        NA        NA        NA FT00003  725629.5  395193.8   609652.6   709672  712048.4  325696.1  582689.3 FT00004 6667479.8 3392535.0 10874295.1 10258668 9681633.2 9478584.9 5519297.2 FT00005 4424076.9 5594730.1  8961144.0  9521460 7483711.7 6722025.8 2419544.4 FT00006 5058937.4 6075048.7  8164059.6  4874998 7531471.2 5897690.0 3338828.4             A5M_R2  A5M_R3      M_R1    M_R2      M_R3    PPL_R1 FT00001         NA      NA   56655.1      NA        NA  127518.4 FT00002         NA      NA        NA      NA        NA  201678.3 FT00003   737115.2  653138  470292.9  357432  463980.4  502676.9 FT00004 10336613.6 6591140 3684237.3 6720029 8384267.6 6198111.3 FT00005 10403154.3 5371937 3405332.8 5232400 8119441.8 2953772.8 FT00006  7827918.6 6753662 5360799.4 4505007 7968544.6 6931111.8 #' determine the number of missing values per sample and plot them nas <- apply(fvals, MARGIN = 2, function(z) sum(is.na(z)))  barplot(nas, main = \"Number of missing values\", col = col_sample)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"chromatographic-peak-detection","dir":"Articles","previous_headings":"","what":"Chromatographic peak detection","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"aim chromatographic peak detection identify quantify signal raw MS data space representing signal ions compounds present sample. Data processing performed separately data file mass peak intensities similar m/z evaluated along retention time axis identify chromatographic peaks. use centWave algorithm peak detection. important parameter centWave peakwidth defines approximate lower upper expected width chromatographic peaks retention time dimension. Without prior information, need derive information data set. therefore zoom areas BPC seem contain signal ion.  Definition example region EIC extraction. Upper panel: BPC, dashed vertical lines indicate selected retention time region. Lower panel: EIC m/z region largest signal retention time window. width chromatographic peaks 8 seconds. evaluate second signal chromatogram.  Definition example region EIC extraction. Upper panel: BPC, dashed vertical lines indicate selected retention time region. Lower panel: EIC m/z region largest signal retention time window. width chromatographic peaks m/z slice seem around 15 seconds. Also, seems considerable shift retention times samples. Based two example signals define peakdwidth parameter present data set 5 20 seconds. real data analysis suggested evaluate signals, also eventually internal standards ions compounds expected present sample. second potentially data set-specific parameter centWave algorithm ppm. defines maximum allowed deviation m/z dimension mass peaks consecutive spectra considered represent signal ion. illustrate subset full MS data first data file m/z retention time range defined plot individual mass peaks. Details ppm centWave parameter ppm parameter defines expected (observed) m/z deviation mass peaks representing signal compound/ion consecutive spectra. scattering mass peak’s m/z values can depend centroiding algorithm used precision MS instrument. addition, TOF instruments, scattering can depend intensity signal, higher variation observed low intensity peaks increasing stability higher signal.  individual mass peaks shown lower panel plot . present ion, m/z values show low variance. evaluate signal also second m/z - retention time window defined .  scattering m/z values looks larger, still 0.001 Da. nevertheless use ppm = 20 present data set - assume ions different compounds elute time difference ppm lower 20. define settings centWave perform chromatographic peak detection full data set. Note can also helpful test different settings performing peak detection extracted ion chromatograms described Metabonaut. Parameter chunkSize defines number data files MS data loaded time. parameter thus influence memory usage analysis. cases also advisable perform peak postprocessing remove artifacts centWave peak detection (e.g. overlapping split peaks). perform peak refinement merge partially completely overlapping chromatographic peak, less 2 seconds apart , intensity apexes lower certain proportion apex intensity lower intensity peak. next compare number identified peaks per sample well m/z retention time widths.  highest number peaks detected PPL sample. Apart sample, numbers detected peaks comparable data set. Also m/z width retention time widths. expected, identified chromatographic peaks 10 seconds wide. Also, m/z width 10 ppm peaks, show also larger m/z widths. also evaluate peak detection results two example m/z - retention time regions. Identified chromatographic peaks colored according sample group.  Chromatographic peak detection results first example EIC.  Chromatographic peak detection results second example EIC.","code":"#' extract BPC par(mfrow = c(2, 1)) bpc <- chromatogram(mse, aggregationFun = \"max\") plot(bpc, col = paste0(col_sample, 80), lwd = 2) grid()  #' identify a retention time region to extract rtr_1 <- c(105, 130) abline(v = rtr_1, lty = 2)  #' identify the m/z with the largest intensity in that region: #' - restrict to MS1 data #' - filter the MS data by retention time #' - extract the MS data as a data.frame tmp <- spectra(mse) |>     filterMsLevel(1L) |>     filterRt(rtr_1) |>     longForm(columns = c(\"mz\", \"intensity\"))  #' define a m/z range around the m/z with largest intensity mzr_1 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)  #' extract an EIC for that RT and m/z region eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1) plot(eic_1, col = paste0(col_sample, 80), lwd = 2) grid() par(mfrow = c(2, 1)) plot(bpc, col = paste0(col_sample, 80), lwd = 2) grid()  #' identify a region to extract rtr_2 <- c(720, 770) abline(v = rtr_2, lty = 2)  #' identify the m/z with the largest intensity in that region: #' - restrict to MS1 data #' - filter the MS data by retention time #' - extract the MS data as a data.frame tmp <- spectra(mse) |>     filterMsLevel(1L) |>     filterRt(rtr_2) |>     longForm(columns = c(\"mz\", \"intensity\"))  #' define a m/z range around the m/z with largest intensity mzr_2 <- tmp$mz[which.max(tmp$intensity)] + c(-0.005, 0.005)  #' extract an EIC for that RT and m/z region eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2) plot(eic_2, col = paste0(col_sample, 80), lwd = 2) grid() mse[1L] |>     filterSpectra(filterMsLevel, 1L) |>     filterSpectra(filterRt, rt = rtr_1) |>     filterSpectra(filterMzRange, mz = mzr_1) |>     plot() mse[1L] |>     filterSpectra(filterMsLevel, 1L) |>     filterSpectra(filterRt, rt = rtr_2) |>     filterSpectra(filterMzRange, mz = mzr_2) |>     plot() #' configure and perform chromatographic peak detection cwp <- CentWaveParam(     ppm = 20,     peakwidth = c(5, 20),     snthresh = 8,     integrate = 2,     mzdiff = 0.001 ) mse <- findChromPeaks(mse, param = cwp, chunkSize = 4L) #' configure and perform *peak refinement* mnpp <- MergeNeighboringPeaksParam(     expandRt = 1,     expandMz = 0,     ppm = 0,     minProp = 0.75) mse <- refineChromPeaks(mse, mnpp, chunkSize = 4L) #' split the detected chrom peaks per sample pk_list <- split.data.frame(     chromPeaks(mse, columns = c(\"mzmin\", \"mzmax\", \"rtmin\", \"rtmax\")),     chromPeaks(mse, columns = \"sample\")[, \"sample\"]) #' calculate mz and rt widths pk_list <- lapply(pk_list, function(z) {     cbind(z, mz_width = z[, \"mzmax\"] - z[, \"mzmin\"],           mz_width_ppm = (z[, \"mzmax\"] - z[, \"mzmin\"]) * 1e6 / z[, \"mzmax\"],           rt_width = z[, \"rtmax\"] - z[, \"rtmin\"]) })  #' plot the information par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1)) barplot(unlist(lapply(pk_list, nrow)),      col = col_sample,      ylab = \"peak count\", main = \"Peak detection summary, mse\", xaxt = \"n\") grid() legend(\"top\", horiz = TRUE, col = col, pch = 15,        legend = names(col)) par(mar = c(0, 4.3, 0, 0.1)) vioplot(lapply(pk_list, function(z) z[, \"mz_width_ppm\"]), outline = FALSE,         ylab = \"m/z width [ppm]\", xaxt = \"n\", line = 3,         col = col_sample) grid() vioplot(lapply(pk_list, function(z) z[, \"rt_width\"]),         ylab = \"rt width [s]\", col = col_sample, line = 3) grid() eic_1 <- chromatogram(mse, mz = mzr_1, rt = rtr_1)  #' define a color for each chromatographic peak col_peak <- col_sample[chromPeaks(eic_1)[, \"sample\"]] plot(eic_1, col = paste0(col_sample, 80),      peakBg = paste0(col_peak, 10),      peakCol = paste0(col_peak, 80)) grid() legend(\"topright\", col = col, lty = 1,        legend = names(col)) eic_2 <- chromatogram(mse, mz = mzr_2, rt = rtr_2)  #' define a color for each chromatographic peak col_peak <- col_sample[chromPeaks(eic_2)[, \"sample\"]] plot(eic_2, col = paste0(col_sample, 80),      peakBg = paste0(col_peak, 10),      peakCol = paste0(col_peak, 80)) grid() legend(\"topright\", col = col, lty = 1,        legend = names(col))"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"retention-time-alignment","dir":"Articles","previous_headings":"","what":"Retention time alignment","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"aim retention time alignment step reduce differences observed elution time compounds different LC-MS runs. variety methods proposed also implemented xcms. use straight forward approach aligns chromatographic runs based retention times anchor peaks, .e., compounds present samples experiment. define anchor peaks must however perform initial correspondence analysis group chromatographic peaks similar m/z retention time across samples. use peak density correspondence method groups chromatographic peaks LC-MS feature, m/z difference smaller binSize (+ ppm m/z), retention time apex within one peak peak density curve (smoothness can configured parameter bw) chromatographic peak present least minFraction least one sample groups defined sampleGroups. initial correspondence apply relaxed settings consider samples sample group (since want define anchor peaks present samples). Details PeakDensityParam settings peak density correspondence method can configured using PeakDensityParam. initial correspondence used retention time alignment relaxed settings can used, also putting samples sample group. important parameters bw binSize. former defines tolerance retention time similarity, latter similarity m/z values chromatographic peaks different samples considered represent signal ions compound. Setting binSize straight forward - depends resolution instrument expected similarity m/z values ion. set value binSize = 0.01, hence chromatographic peaks difference m/z smaller 0.01 evaluated. bw parameter bit difficult define. defined based observed data experiment, ideally, EICs closely eluting compounds m/z. example use second example m/z - retention time range, seemed contain signal compound, quite large shifts data files. simulate correspondence analysis EIC. parameters defined minFraction, defines minimum required proportion samples one sample groups defined parameter sampleGroups chromatographic peak present, ppm , together binSize defines maximal accepted difference chromatographic peaks’ m/z values consider grouping.  Correspondence analysis simulation second example EIC. upper panel plot shows EIC, lower panel data considered correspondence: shows retention time apex positions chromatographic peaks m/z slice x-axis sample chromatographic peak detected y-axis. black solid line represents peak density estimate, calculated based retention times chromatographic peaks parameter bw larger values bw resulting smooth curves. used settings, particular parameter bw, present chromatographic peaks split two separate LC-MS features (indicated grey rectangle lower panel). Assuming peaks region represent signal ions compound, however want group feature. hence next increase bw parameter simulate correspondence updated settings.  Correspondence analysis simulation bw = 5. Changing bw 5 changed density curve, still defined two separate features. thus increase bw 7.  Correspondence analysis simulation bw = 7. bw = 7 single feature defined. use parameter initial correspondence analysis full data set. retention time alignment use mentioned peak groups method aligns LC runs minimizing retention time differences called anchor peaks. alignment method robust also flexible, allowing example align samples based within-experiment QC samples, external reference data based manually defined anchor peaks. See Metabonaut examples options. method can configured PeakGroupsParam(). minFraction = 0.9 define anchor peaks LC-MS features (defined initial correspondence analysis) chromatographic peak identified 90% samples whole experiment. observed retention time differences used model curve along retention time dimension used align retention times samples. smoothness curve can configured parameter span (values 0 1; values around 0.5 work cases). effect alignment can visualized plotAdjustedRtime() function. plots adjusted retention times sample x-axis difference adjusted raw retention times y-axis solid line. Retention times anchor peaks sample indicated individual data points. ideally placed along full retention time range experiment.  Retention time alignment results. Anchor points span full retention time range. Retention time adjustments samples 2-4 seconds, exception 3 samples considerably larger adjustment present 500 seconds, PPL sample larger retention time differences 650 seconds. next evaluate alignment results based BPC alignment.  BPC (top) (bottom) retention time alignment. Misalignment signal later stage chromatography seems reduced. addition evaluate effect retention time alignment two example EICs.  First example EIC (top) (bottom) retention time alignment. early retention time range already raw signal well aligned.  Second example EIC (top) (bottom) retention time alignment. later retention time range shows clear, strong, differences retention times 4 samples. PPL sample aligned quite well using settings, 3 samples still show considerable shifts retention times. thus re-perform alignment reducing value span parameter switch local alignment samples. first undo retention time alignment, re-perform initial correspondence analysis perform alignment changed settings parameter span. Evaluating impact changing parameter.  Retention time alignment results. stronger alignment can observed retention time area 750 800 seconds. results first example EIC change.  First example EIC (top) (bottom) retention time alignment. second EIC alignment improved.  Second example EIC (top) (bottom) retention time alignment. Note cases necessary samples perfectly aligned. variation retention time can accounted final correspondence analysis.","code":"pdp <- PeakDensityParam(     sampleGroups = rep(1, length(mse)),     bw = 2,     minFraction = 0.2,     binSize = 0.01,     ppm = 10)  col_peak <- col_sample[chromPeaks(eic_2)[, \"sample\"]] plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 5 plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 7 plotChromPeakDensity(eic_2, param = pdp, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40)) grid() #' perform initial correspondence analysis to group chromatographic peaks mse <- groupChromPeaks(mse, param = pdp) #' configure and run retention time alignment pgp <- PeakGroupsParam(     minFraction = 0.90,     span = 0.4) mse <- adjustRtime(mse, param = pgp) #' visualize alignment results plotAdjustedRtime(mse, col = paste0(col_sample, 80),                   peakGroupsPch = 21, lwd = 2) grid() legend(\"topleft\", col = col, lty = 1,        legend = names(col)) #' create a BPC after adjustment; chromPeaks = \"none\" only creates the BPC #' without extracting also identified chromatographic peaks. bpc_adj <- chromatogram(mse, chromPeaks = \"none\", aggregationFun = \"max\")  par(mfrow = c(2, 1)) plot(bpc, col = paste0(col_sample, 80), main = \"BPC, raw\", lwd = 2) grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(bpc_adj, col = paste0(col_sample, 80), main = \"BPC, adjusted\", lwd = 2) grid() eic_1_adj <- chromatogram(mse, rt = rtr_1, mz = mzr_1, chromPeaks = \"none\")  par(mfrow = c(2, 1)) plot(eic_1, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_1_adj, col = paste0(col_sample, 80), lwd = 2) grid() eic_2_adj <- chromatogram(mse, rt = rtr_2, mz = mzr_2, chromPeaks = \"none\")  par(mfrow = c(2, 1)) plot(eic_2, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_2_adj, col = paste0(col_sample, 80), lwd = 2) grid() #' remove retention time alignment results mse <- dropAdjustedRtime(mse) #' re-perform initial correspondence mse <- groupChromPeaks(mse, param = pdp) #' perform the alignment using updated settings pgp <- PeakGroupsParam(     minFraction = 0.90,     span = 0.1) mse <- adjustRtime(mse, param = pgp) #' visualize alignment results plotAdjustedRtime(mse, col = paste0(col_sample, 80),                   peakGroupsPch = 21, lwd = 2) grid() legend(\"topleft\", col = col, lty = 1,        legend = names(col)) eic_1_adj <- chromatogram(mse, rt = rtr_1, mz = mzr_1)  par(mfrow = c(2, 1)) #' Setting peakType = \"none\" prevents identified chromatographic peaks to be #' indicated in the plot. plot(eic_1, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_1_adj, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() eic_2_adj <- chromatogram(mse, rt = rtr_2, mz = mzr_2)  par(mfrow = c(2, 1)) plot(eic_2, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid() legend(\"topright\", col = col, legend = names(col), lty = 1, lwd = 2) plot(eic_2_adj, col = paste0(col_sample, 80), lwd = 2, peakType = \"none\") grid()"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"correspondence-analysis","dir":"Articles","previous_headings":"","what":"Correspondence analysis","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"correspondence analysis groups chromatographic peaks different samples, assumed represent signal ions compound, LC-MS features. Signals generally grouped together based similarity m/z retention times. use peak density method , similarly previous section, first evaluate impact different parameter settings expected results. Also, final correspondence use samples’ sample_name parameter sampleGroup. Combined setting minFraction = 0.67, LC-MS feature defined chromatographic peak present least 67% replicates per sample (.e., 2 3). evaluate settings, particular effect bw first example EIC.  Simulation correspondence analysis first example EIC. EIC settings worked nicely. Simulating correspondence second example EIC.  Simulation correspondence analysis second example EIC. Also second EIC chromatographic peaks got grouped feature. Ideally, correspondence parameters also simulated complex signals, e.g. regions co- closely eluting compounds. expand retention time window m/z slice first example EIC.  Simulation correspondence analysis expanded RT window. seem signal 3 different compounds m/z slice. Using settings , particular bw = 7 apparently different chromatographic signals 105 115 seconds grouped LC-MS feature indicated grey rectangle plot . Unless want signals grouped together, need reduce value bw. simulate correspondence using bw = 3.  Effect changing bw = 3 correspondence analysis. bw = 3 successfully grouped signals 3 distinct features. next evaluate whether updated setting still group signal second example EIC single feature.  Effect bw = 3 correspondence results second example EIC. chromatographic peaks region grouped single region. thus proceed use settings correspondence analysis full data set. advised check results correspondence analysis, also evaluate impact settings like binSize ppm assure validity defined LC-MS features. Ideally, larger number EICs/features checked. extract first example EIC evaluate correspondence results . important set simulate = FALSE show actual results.  Correspondence results first example EIC. chromatographic peaks grouped feature. retention time (\"rtmed\") feature indicated dashed vertical line. next evaluate results also second example EIC.  Correspondence results second example EIC. Also retention time region, chromatographic peaks grouped single feature. last evaluate expanded retention time region m/z range first example EIC.  Correspondence results m/z slice multiple closely eluting compounds. region, chromatographic peaks grouped 3 distinct features. results correspondence analysis can extracted result object using featureDefinitions() featureValues() functions. former returns definition LC-MS features, .e., m/z retention time, latter actual abundance estimates different samples. count number features defined correspondence analysis: quite large number features defined. mostly due setting minFraction parameter, required chromatographic peak detected 2 3 replicates individual sample define, combine , feature. can now extract abundance estimates features featureValues() function. extract data matrix assign unique sample name column names (default MS data file name used). Columns abundance matrix samples, rows features. present data set large number missing values. missing value indicates failure detect chromatographic peak m/z - retention time region feature sample. can multiple reasons: compound might simply present sample original signal noisy, low abundance, fit expected shape peak detection algorithm identify chromatographic peak. calculate plot number missing values per sample.  Number missing feature values per sample. lowest number missing values present PPL_R1 sample.","code":"#' configure the *peak density* correspondence method pdp <- PeakDensityParam(     sampleGroups = sampleData(mse)$sample_name,     minFraction = 0.67,     binSize = 0.01,     ppm = 10,     bw = 7) col_peak <- col_sample[chromPeaks(eic_1_adj)[, \"sample\"]] plotChromPeakDensity(eic_1_adj, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() col_peak <- col_sample[chromPeaks(eic_2_adj)[, \"sample\"]] plotChromPeakDensity(eic_2_adj, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() a <- chromatogram(mse, mz = mzr_1, rt = c(30, 150))  col_peak <- col_sample[chromPeaks(a)[, \"sample\"]] plotChromPeakDensity(a, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() pdp@bw <- 3 plotChromPeakDensity(a, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() col_peak <- col_sample[chromPeaks(eic_2_adj)[, \"sample\"]] plotChromPeakDensity(eic_2_adj, param = pdp, col = col_sample,                      peakCol = col_peak, peakBg = paste0(col_peak, 40)) grid() #' perform correspondence analysis on the full data set mse <- groupChromPeaks(mse, param = pdp) eic_1 <- chromatogram(mse, rt = rtr_1, mz = mzr_1)  #' plot the actual correspondence results by setting `simulate = FALSE` col_peak <- col_sample[chromPeaks(eic_1)[, \"sample\"]] plotChromPeakDensity(eic_1, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40),                      simulate = FALSE) grid() eic_2 <- chromatogram(mse, rt = rtr_2, mz = mzr_2)  #' plot the actual correspondence results by setting `simulate = FALSE` col_peak <- col_sample[chromPeaks(eic_2)[, \"sample\"]] plotChromPeakDensity(eic_2, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40),                      simulate = FALSE) grid() a <- chromatogram(mse, mz = mzr_1, rt = c(30, 150))  col_peak <- col_sample[chromPeaks(a)[, \"sample\"]] plotChromPeakDensity(a, col = col_sample, peakCol = col_peak,                      peakBg = paste0(col_peak, 40),                      simulate = FALSE) grid() featureDefinitions(mse) |>     nrow() [1] 14808 fvals <- featureValues(mse, method = \"sum\") colnames(fvals) <- sampleData(mse)$sample_desc head(fvals) A15M_R1 A15M_R2 A15M_R3  A45M_R1 A45M_R2 A45M_R3  A5M_R1 A5M_R2 A5M_R3 FT00001      NA      NA      NA       NA      NA      NA      NA     NA     NA FT00002      NA      NA      NA       NA      NA      NA      NA     NA     NA FT00003      NA      NA      NA       NA      NA      NA      NA     NA     NA FT00004      NA 3392535      NA 10258668      NA 9478585 5519297     NA     NA FT00005      NA      NA      NA  9521460      NA 6722026 2419544     NA     NA FT00006      NA      NA      NA  4874998      NA 5897690 3338828     NA     NA            M_R1 M_R2 M_R3    PPL_R1 FT00001      NA   NA   NA  127518.4 FT00002      NA   NA   NA  201678.3 FT00003      NA   NA   NA  502676.9 FT00004 3684237   NA   NA 6198111.3 FT00005 3405333   NA   NA 2953772.8 FT00006      NA   NA   NA 6931111.8 #' determine the number of missing values per sample and plot them nas <- apply(fvals, MARGIN = 2, function(z) sum(is.na(z)))  barplot(nas, main = \"Number of missing values\", col = col_sample)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"gap-filling","dir":"Articles","previous_headings":"","what":"Gap-filling","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"reduce number missing values avoid data imputation perform gap-filling: samples missing value feature (.e., chromatographic peak detected) integrate intensities measured within m/z - retention time area feature. default, area defined 25% 75% quantile lower, respectively upper m/z (retention time) boundary chromatographic peaks feature. example calculate area featureArea() function first 6 features: Thus, gap-filling, missing values replaced integrated signal measured MS instrument within m/z - retention time boundaries. perform gap-filling full data set. extract feature values determine number missing values.  Number missing feature values per sample gap-filling. considerable amount values thus rescued.","code":"featureArea(mse,             mzmin = function(z) quantile(z, probs = 0.25, na.rm = TRUE),             mzmax = function(z) quantile(z, probs = 0.75, na.rm = TRUE),             rtmin = function(z) quantile(z, probs = 0.25, na.rm = TRUE),             rtmax = function(z) quantile(z, probs = 0.75, na.rm = TRUE),             features = rownames(featureDefinitions(mse))[1:4]) mzmin    mzmax    rtmin    rtmax FT00001 150.0268 150.0270 588.3672 594.2322 FT00002 150.0789 150.0791 166.7511 175.2998 FT00003 150.0912 150.0916 245.4199 254.4996 FT00004 150.1022 150.1030 812.2422 837.7419 #' configure and perform gap-filling cpap <- ChromPeakAreaParam(minMzWidthPpm = 10) mse <- fillChromPeaks(mse, param = cpap, chunkSize = 4L) fvals <- featureValues(mse, method = \"sum\") colnames(fvals) <- sampleData(mse)$sample_desc head(fvals) A15M_R1   A15M_R2    A15M_R3  A45M_R1   A45M_R2   A45M_R3    A5M_R1 FT00001        NA        NA         NA       NA        NA        NA        NA FT00002        NA        NA         NA       NA        NA        NA        NA FT00003  725629.5  395193.8   609652.6   709672  712048.4  325696.1  582689.3 FT00004 6667479.8 3392535.0 10874295.1 10258668 9681633.2 9478584.9 5519297.2 FT00005 4424076.9 5594730.1  8961144.0  9521460 7483711.7 6722025.8 2419544.4 FT00006 5058937.4 6075048.7  8164059.6  4874998 7531471.2 5897690.0 3338828.4             A5M_R2  A5M_R3      M_R1    M_R2      M_R3    PPL_R1 FT00001         NA      NA   56655.1      NA        NA  127518.4 FT00002         NA      NA        NA      NA        NA  201678.3 FT00003   737115.2  653138  470292.9  357432  463980.4  502676.9 FT00004 10336613.6 6591140 3684237.3 6720029 8384267.6 6198111.3 FT00005 10403154.3 5371937 3405332.8 5232400 8119441.8 2953772.8 FT00006  7827918.6 6753662 5360799.4 4505007 7968544.6 6931111.8 #' determine the number of missing values per sample and plot them nas <- apply(fvals, MARGIN = 2, function(z) sum(is.na(z)))  barplot(nas, main = \"Number of missing values\", col = col_sample)"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"extract-fragment-spectra-for-lc-ms-features","dir":"Articles","previous_headings":"","what":"Extract fragment spectra for LC-MS features","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"preprocessing, next identify extract MS2 spectra defined LC-MS features. use featureSpectra() method, identifies features’ chromatographic peaks MS2 spectra (within sample!) retention time precursor m/z within retention time m/z range chromatographic peak. can multiple, , MS2 spectra per feature: next inspect identified MS2 spectra.  MS2 spectra one LC-MS feature. MS2 spectra look similar - next calculate also pairwise similarity visualize results heatmap.  Pairwise spectra similarity MS2 spectra one feature. Similarity MS2 spectra high (0.92). next combine individual MS2 spectra feature single consensus spectrum. Options combine spectra Multiple spectra can combined single spectrum using combineSpectra() function provides large number options parameters task, including possibility provide custom function combine fragment peaks. default (parameter peaks = \"union\"), combined spectrum contains mass peaks input spectra. option peaks = \"intersect\" allows retain peaks present certain proportion input spectra. Parameters ppm tolerance define required similarity peaks’ m/z value considered . groups spectra combined specified parameter f potential splitting input Spectra object parallel processing parameter p. example, combine MS2 spectra keeping mass peaks present least 75% input spectra. thus now one consensus spectrum per feature. summary numbers peaks per consensus spectrum shown . consensus spectrum first feature shown .  Consensus spectrum first feature. next filter data remove spectra single fragment peak. Additional spectra processing options Spectra package provide many additional functions options process, scale clean spectra. alternative, SpectriPy package, also possible apply Python-based functionality e.g. matchms Python library Spectra objects. last visualize select data (.e. features associated MS2 spectra) m/z - retention time space. use featureArea() function get feature boundaries draw rectangles. associated MS2 spectra (precursor m/z retention time value) added individual data points.  Feature areas (grey rectangles) associated MS2 spectra (blue points) retention time - m/z space. Thus, little bit R coding can easily create customized data visualizations.","code":"#' identify MS2 spectra for features ms2 <- featureSpectra(mse) ms2 MSn data (Spectra) with 21917 spectra in a MsBackendMzR backend:         msLevel     rtime scanIndex       <integer> <numeric> <integer> 1             2   169.361       834 2             2   169.909       837 3             2   170.225       844 4             2   169.786       845 5             2   169.721       844 ...         ...       ...       ... 21913         2   748.486      3747 21914         2   747.600      3748 21915         2   744.174      3679 21916         2   748.223      3744 21917         2   749.801      3791  ... 40 more variables/columns.  file(s): Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep2.mzML Interlab-LC-MS_Lab2_A15M_Pos_MS2_Rep3.mzML Interlab-LC-MS_Lab2_A45M_Pos_MS2_Rep1.mzML  ... 10 more files Processing:  Filter: select retention time [20..850] on MS level(s)  [Thu Dec 11 14:59:07 2025]  Filter: select MS level(s) 2 [Thu Dec 11 15:05:17 2025]  Filter: select MS level(s) 2 [Thu Dec 11 15:05:20 2025]  ...4 more processings. Use 'processingLog' to list all. #' count the number of MS2 spectra per feature ms2_count <- table(ms2$feature_id)  #' the number of LC-MS features with at least one MS2 spectrum: length(ms2_count) [1] 3091 #' the average number of MS2 spectra per feature: mean(ms2_count) [1] 7.090586 #' select MS2 spectra for the first feature a <- ms2[ms2$feature_id == ms2$feature_id[1]]  #' plot the spectra plotSpectra(a) #' calculate dot product similarity sim <- compareSpectra(a, ppm = 10, tolerance = 0)  pheatmap(sim) #' define consensus spectra per feature ms2_cons <- combineSpectra(ms2, f = ms2$feature_id,                            p = rep(1, length(ms2)),                            peaks = \"intersect\",                            ppm = 10, minProp = 0.75) ms2_cons MSn data (Spectra) with 3091 spectra in a MsBackendMemory backend:        msLevel     rtime scanIndex      <integer> <numeric> <integer> 1            2  169.3607       834 2            2  147.8949       725 3            2   35.3421       164 4            2  836.9768      4221 5            2  310.3339      1548 ...        ...       ...       ... 3087         2   610.293      3053 3088         2   608.046      3050 3089         2   794.229      3958 3090         2   744.275      3673 3091         2   749.801      3791  ... 40 more variables/columns. Processing:  Filter: select retention time [20..850] on MS level(s)  [Thu Dec 11 14:59:07 2025]  Filter: select MS level(s) 2 [Thu Dec 11 15:05:17 2025]  Filter: select MS level(s) 2 [Thu Dec 11 15:05:20 2025]  ...5 more processings. Use 'processingLog' to list all. #' overview on the number of peaks per spectrum quantile(lengths(ms2_cons)) 0%   25%   50%   75%  100%   1.0  66.5 102.0 146.0 463.0 plotSpectra(ms2_cons[1], lwd = 2) grid() #' remove spectra with a single fragment peak ms2_cons <- ms2_cons[lengths(ms2_cons) > 1] ms2_cons MSn data (Spectra) with 3089 spectra in a MsBackendMemory backend:        msLevel     rtime scanIndex      <integer> <numeric> <integer> 1            2  169.3607       834 2            2  147.8949       725 3            2   35.3421       164 4            2  836.9768      4221 5            2  310.3339      1548 ...        ...       ...       ... 3085         2   610.293      3053 3086         2   608.046      3050 3087         2   794.229      3958 3088         2   744.275      3673 3089         2   749.801      3791  ... 40 more variables/columns. Processing:  Filter: select retention time [20..850] on MS level(s)  [Thu Dec 11 14:59:07 2025]  Filter: select MS level(s) 2 [Thu Dec 11 15:05:17 2025]  Filter: select MS level(s) 2 [Thu Dec 11 15:05:20 2025]  ...5 more processings. Use 'processingLog' to list all. #' define the feature boundaries fa <- featureArea(mse, features = ms2_cons$feature_id)  #' plot feature areas as rectangles plot(NA, NA, xlim = range(fa[, c(\"rtmin\", \"rtmax\")]),      ylim = range(fa[, c(\"mzmin\", \"mzmax\")]),      xlab = \"retention time\", ylab = \"m/z\") grid() rect(xleft = fa[, \"rtmin\"], xright = fa[, \"rtmax\"],      ybottom = fa[, \"mzmin\"], ytop = fa[, \"mzmax\"],      border = \"#00000080\") #' add precursor m/z and retention times of MS2 points(ms2_cons$rtime, ms2_cons$precursorMz,        cex = 0.5, col = \"#0000ff40\")"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"formatting-and-exporting-data-for-fbmn","dir":"Articles","previous_headings":"","what":"Formatting and exporting data for FBMN","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"next export feature abundance matrix fragment spectra feature-based molecular networking GNPS. Similar original workflow (Rainer Louail 2025) described (Nothias et al. 2020) write feature matrix tabulator delimited text file associated MS2 spectra file Mascot Generic File (MGF) format. future version workflow might use mzTab-M format data exchange. first compile feature abundance matrix export txt file. next reformat information MS2 spectra restricting data required GNPS. respective functionality present provided xcms-gnps-tools GitHub repo. finally export MS2 spectra MGF format. Spectra data export formats MGF format loosely defined many different dialects used. MsBackendMgf package supports renaming specifying spectra variables (metadata) export MGF format. addition, also allow export also additional peak information, chemical formulas individual fragments. alternative, also export formats supported Spectra objects, provided packages MsBackendMsp MsBackendMassbank. Upcoming formats, specLib, mzPeak updated mzTab-M format supported future.","code":"#' get feature definitions fdef <- featureDefinitions(mse)[, c(\"mzmed\", \"mzmin\", \"mzmax\",                                     \"rtmed\", \"rtmin\", \"rtmax\")] #' combine with the feature value table fvals <- cbind(Row.names = rownames(fdef), fdef, fvals)  #' restrict the feature abundance matrix to features with MS2 spectra fvals <- fvals[ms2_cons$feature_id, ]  #' export the data write.table(fvals, \"xcms_ms2_features.txt\", sep = \"\\t\",             quote = FALSE, row.names = FALSE) #' load functions for GNPS-specific spectra formatting source(\"https://raw.githubusercontent.com/jorainer/xcms-gnps-tools/master/customFunctions.R\") ms2_cons <- formatSpectraForGNPS(ms2_cons) #' export the MS2 spectra in MGF format export(ms2_cons, backend = MsBackendMgf(),        file = \"xcms_ms2_spectra.mgf\")"},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"R-based data analysis workflows allow data set specific, tailored, analysis LC-MS data. xcms R package LC-MS data preprocessing tightly integrated broader ecosystem R packages. quarto system also allow combining R Python functionality workflow document SpectriPy R-package translating R Python MS data structures.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/articles/MSV000090156-preprocessing.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"xcms-based preprocessing of LC-MS/MS data for feature-based molecular networking with GNPS2","text":"R version package versions used:","code":"sessionInfo() R version 4.5.2 (2025-10-31) Platform: x86_64-pc-linux-gnu Running under: Ubuntu 24.04.3 LTS  Matrix products: default BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0  locale:  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C  [9] LC_ADDRESS=C               LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C  time zone: Etc/UTC tzcode source: system (glibc)  attached base packages: [1] stats4    stats     graphics  grDevices utils     datasets  methods [8] base  other attached packages:  [1] vioplot_0.5.1       zoo_1.8-14          sm_2.2-6.0  [4] pheatmap_1.0.13     pander_0.6.6        RColorBrewer_1.1-3  [7] MsBackendMgf_1.18.0 xcms_4.8.0          Spectra_1.20.0 [10] BiocParallel_1.44.0 S4Vectors_0.48.0    BiocGenerics_0.56.0 [13] generics_0.1.4      MsExperiment_1.12.0 ProtGenerics_1.42.0  loaded via a namespace (and not attached):  [1] DBI_1.2.3                   rlang_1.1.6  [3] magrittr_2.0.4              clue_0.3-66  [5] MassSpecWavelet_1.76.0      matrixStats_1.5.0  [7] compiler_4.5.2              vctrs_0.6.5  [9] reshape2_1.4.5              stringr_1.6.0 [11] pkgconfig_2.0.3             MetaboCoreUtils_1.18.1 [13] crayon_1.5.3                fastmap_1.2.0 [15] XVector_0.50.0              rmarkdown_2.30 [17] preprocessCore_1.72.0       purrr_1.2.0 [19] xfun_0.54                   MultiAssayExperiment_1.36.1 [21] jsonlite_2.0.0              progress_1.2.3 [23] DelayedArray_0.36.0         parallel_4.5.2 [25] prettyunits_1.2.0           cluster_2.1.8.1 [27] R6_2.6.1                    stringi_1.8.7 [29] limma_3.66.0                GenomicRanges_1.62.0 [31] Rcpp_1.1.0                  Seqinfo_1.0.0 [33] SummarizedExperiment_1.40.0 iterators_1.0.14 [35] knitr_1.50                  IRanges_2.44.0 [37] BiocBaseUtils_1.12.0        Matrix_1.7-4 [39] igraph_2.2.1                tidyselect_1.2.1 [41] abind_1.4-8                 yaml_2.3.12 [43] doParallel_1.0.17           codetools_0.2-20 [45] affy_1.88.0                 lattice_0.22-7 [47] tibble_3.3.0                plyr_1.8.9 [49] Biobase_2.70.0              S7_0.2.1 [51] evaluate_1.0.5              pillar_1.11.1 [53] affyio_1.80.0               BiocManager_1.30.27 [55] MatrixGenerics_1.22.0       foreach_1.5.2 [57] MSnbase_2.36.0              MALDIquant_1.22.3 [59] ncdf4_1.24                  hms_1.1.4 [61] ggplot2_4.0.1               scales_1.4.0 [63] glue_1.8.0                  MsFeatures_1.18.0 [65] lazyeval_0.2.2              tools_4.5.2 [67] mzID_1.48.0                 data.table_1.17.8 [69] QFeatures_1.20.0            vsn_3.78.0 [71] mzR_2.44.0                  fs_1.6.6 [73] XML_3.99-0.20               grid_4.5.2 [75] impute_1.84.0               tidyr_1.3.1 [77] MsCoreUtils_1.22.1          PSMatch_1.14.0 [79] cli_3.6.5                   S4Arrays_1.10.1 [81] dplyr_1.1.4                 AnnotationFilter_1.34.0 [83] pcaMethods_2.2.0            gtable_0.3.6 [85] digest_0.6.39               SparseArray_1.10.6 [87] farver_2.1.2                htmltools_0.5.9 [89] lifecycle_1.0.4             statmod_1.5.1 [91] MASS_7.3-65"},{"path":[]},{"path":"https://jorainer.github.io/xcms4gnps2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Philippine Louail. Author.            European Union HORIZON-MSCA-2021 project                    Grant . 101073062: HUMAN – Harmonising Unifying Blood                    Metabolic Analysis Networks Johannes Rainer. Author, maintainer. Steffen Neumann. Contributor.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Louail P, Rainer J (2025). xcms4gnps2: xcms-based data preprocessing FBMN GNPS2. R package version 1.0.0, https://github.com/jorainer/xcms4gnps2/.","code":"@Manual{,   title = {xcms4gnps2: xcms-based data preprocessing for FBMN with GNPS2},   author = {Philippine Louail and Johannes Rainer},   year = {2025},   note = {R package version 1.0.0},   url = {https://github.com/jorainer/xcms4gnps2/}, }"},{"path":"https://jorainer.github.io/xcms4gnps2/index.html","id":"xcms-based-lc-msms-data-preprocessing-for-fbmn-with-gnps2","dir":"","previous_headings":"","what":"xcms-based data preprocessing for FBMN with GNPS2","title":"xcms-based data preprocessing for FBMN with GNPS2","text":"repository contains example workflow preprocessing preparation LC-MS/MS data set feature-based molecular networking (FBMN) GNPS2.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcms4gnps2/index.html","id":"xcms-based-preprocessing-for-fbms-with-gnps","dir":"","previous_headings":"Analysis workflow","what":"xcms-based preprocessing for FBMS with GNPS","title":"xcms-based data preprocessing for FBMN with GNPS2","text":"workflow explains preprocessing public LC-MS/MS data set xcms export results feature-based molecular networking GNPS. 🎥 video recording presentation workshop available https://youtu./yc6fsegFg-k.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/index.html","id":"pushpin-reproducibility--usage","dir":"","previous_headings":"","what":"📌 Reproducibility & Usage","title":"xcms-based data preprocessing for FBMN with GNPS2","text":"workflow available pre-rendered webpage xcms4gnps. addition, docker image available allowing run workflow interactively: don’t already , install docker. Find installation information . Get docker image tutorial e.g. command line : Start docker container, either Docker Desktop, command line Enter http://localhost:8787 web browser log username rstudio password bioc. RStudio server version: open Quarto files vignettes folder evaluate R code blocks document.","code":"docker pull jorainer/xcms4gnps2:latest docker run -e PASSWORD=bioc -p 8787:8787 jorainer/xcms4gnps2:latest"},{"path":"https://jorainer.github.io/xcms4gnps2/index.html","id":"handshake-contribution","dir":"","previous_headings":"","what":"🤝 Contribution","title":"xcms-based data preprocessing for FBMN with GNPS2","text":"Interested contributing? Please check RforMassSpectrometry Contributions Guide.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/index.html","id":"scroll-code-of-conduct","dir":"","previous_headings":"🤝 Contribution","what":"📜 Code of Conduct","title":"xcms-based data preprocessing for FBMN with GNPS2","text":"follow RforMassSpectrometry Code Conduct maintain inclusive respectful community.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/index.html","id":"raised_hands-acknowledgements","dir":"","previous_headings":"","what":"🙌 Acknowledgements","title":"xcms-based data preprocessing for FBMN with GNPS2","text":"Part work funded European Union HORIZON-MSCA-2021 project 101073062: HUMAN – Harmonising Unifying Blood Metabolic Analysis Networks. 🔗 Learn : HUMAN Project Website","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcms4gnps2/news/index.html","id":"changes-in-version-1-0","dir":"Changelog","previous_headings":"","what":"Changes in version 1.0.0","title":"xcms-gnps2 version 1.0","text":"Fix misspellings FBMN.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcms4gnps2/news/index.html","id":"changes-in-version-0-99","dir":"Changelog","previous_headings":"","what":"Changes in version 0.99.4","title":"xcms-gnps2 version 0.99","text":"Add condensed version preprocessing","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/news/index.html","id":"changes-in-version-0-99-1","dir":"Changelog","previous_headings":"","what":"Changes in version 0.99.3","title":"xcms-gnps2 version 0.99","text":"Add export GNPS.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/news/index.html","id":"changes-in-version-0-99-2","dir":"Changelog","previous_headings":"","what":"Changes in version 0.99.2","title":"xcms-gnps2 version 0.99","text":"Add MS2 spectra extraction section.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/news/index.html","id":"changes-in-version-0-99-3","dir":"Changelog","previous_headings":"","what":"Changes in version 0.99.1","title":"xcms-gnps2 version 0.99","text":"Move details collapsable elements.","code":""},{"path":"https://jorainer.github.io/xcms4gnps2/news/index.html","id":"changes-in-version-0-99-4","dir":"Changelog","previous_headings":"","what":"Changes in version 0.99.0","title":"xcms-gnps2 version 0.99","text":"Initial definition docker image restructuring according docker-based workflows.","code":""}]
